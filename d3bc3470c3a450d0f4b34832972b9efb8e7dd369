{
  "comments": [
    {
      "key": {
        "uuid": "baa041b7_4d4e77c2",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T17:16:00Z",
      "side": 1,
      "message": "why not just use a concurrenthashmap here?",
      "range": {
        "startLine": 45,
        "startChar": 34,
        "endLine": 45,
        "endChar": 46
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_70358ed9",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-28T18:39:37Z",
      "side": 1,
      "message": "So, I\u0027m using the paradigm used in RxJava, where a State keeps an immutable set of objects, represented here by this java HashMap (I used java because it generates less garbage than the scala one). Any change in the set creates a new state, where the transition from one state to the other is atomic. This has the advantage of providing consistent O(1) snapshots, whereas iterating over a concurrenthashmap doesn\u0027t guarantee that the elements haven\u0027t been modified since the beginning of the iteration (afaik).\n\nHere the main reason is when closing the manager: with an compareAndSwap we can transition to Closed while the previous state returns all contexts (none can be modified in between).",
      "parentUuid": "baa041b7_4d4e77c2",
      "range": {
        "startLine": 45,
        "startChar": 34,
        "endLine": 45,
        "endChar": 46
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_b0df9639",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "Ok. makes more sense now. In that case, I\u0027d make State itself a trait, and rename what you have as \"State\" now as \"Running\". Init extends Running. Closed is it\u0027s own State, that just extends State. There\u0027s no need for closed flag, it\u0027s redundant with the class itself.\n\nMaybe add a comment on what the state machine and possible transitions are also (basically what you replied to me).",
      "parentUuid": "baa041b7_70358ed9",
      "range": {
        "startLine": 45,
        "startChar": 34,
        "endLine": 45,
        "endChar": 46
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_6d4ffbbe",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T17:16:00Z",
      "side": 1,
      "message": "2 states isn\u0027t really a state machine, especially when they both contain the same state.",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 79,
        "endChar": 5
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_5034cadc",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-28T18:39:37Z",
      "side": 1,
      "message": "These are just 2 singletons representing the initial and final states. Any state in between is just an instance of State with any number of contexts.",
      "parentUuid": "baa041b7_6d4ffbbe",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 79,
        "endChar": 5
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_70e22e03",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 149,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "if you change the hierarchy as I said above, this can turn to using a match, which i think would be cleaner.",
      "range": {
        "startLine": 146,
        "startChar": 12,
        "endLine": 149,
        "endChar": 13
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_50f16acc",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 156,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "what does shutdown mean in this context?",
      "range": {
        "startLine": 156,
        "startChar": 37,
        "endLine": 156,
        "endChar": 45
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_3015c6e4",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 158,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "break",
      "range": {
        "startLine": 158,
        "startChar": 16,
        "endLine": 158,
        "endChar": 22
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_30eca6f2",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 178,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "this could get, null check and close could be encapsulated in the State itself.",
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_4de557a6",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 251,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T17:16:00Z",
      "side": 1,
      "message": "since this only happens when the state is closed and closed is the terminal state, this here is an infinite loop.",
      "range": {
        "startLine": 251,
        "startChar": 24,
        "endLine": 251,
        "endChar": 54
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_9041323c",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 251,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-28T18:39:37Z",
      "side": 1,
      "message": "this is thrown when the cache is closed, not the manager (i.e. handles a race to a table cache that is about to close because it\u0027s last subscribe has unsubscribed). the next iteration should create a new cache that doesn\u0027t throw (or it only does if it\u0027s subject to the same concurrent access)",
      "parentUuid": "baa041b7_4de557a6",
      "range": {
        "startLine": 251,
        "startChar": 24,
        "endLine": 251,
        "endChar": 54
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}