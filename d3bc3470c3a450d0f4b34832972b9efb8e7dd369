{
  "comments": [
    {
      "key": {
        "uuid": "baa041b7_4d4e77c2",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T17:16:00Z",
      "side": 1,
      "message": "why not just use a concurrenthashmap here?",
      "range": {
        "startLine": 45,
        "startChar": 34,
        "endLine": 45,
        "endChar": 46
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_70358ed9",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-28T18:39:37Z",
      "side": 1,
      "message": "So, I\u0027m using the paradigm used in RxJava, where a State keeps an immutable set of objects, represented here by this java HashMap (I used java because it generates less garbage than the scala one). Any change in the set creates a new state, where the transition from one state to the other is atomic. This has the advantage of providing consistent O(1) snapshots, whereas iterating over a concurrenthashmap doesn\u0027t guarantee that the elements haven\u0027t been modified since the beginning of the iteration (afaik).\n\nHere the main reason is when closing the manager: with an compareAndSwap we can transition to Closed while the previous state returns all contexts (none can be modified in between).",
      "parentUuid": "baa041b7_4d4e77c2",
      "range": {
        "startLine": 45,
        "startChar": 34,
        "endLine": 45,
        "endChar": 46
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_b0df9639",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "Ok. makes more sense now. In that case, I\u0027d make State itself a trait, and rename what you have as \"State\" now as \"Running\". Init extends Running. Closed is it\u0027s own State, that just extends State. There\u0027s no need for closed flag, it\u0027s redundant with the class itself.\n\nMaybe add a comment on what the state machine and possible transitions are also (basically what you replied to me).",
      "parentUuid": "baa041b7_70358ed9",
      "range": {
        "startLine": 45,
        "startChar": 34,
        "endLine": 45,
        "endChar": 46
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_79269917",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-29T09:54:40Z",
      "side": 1,
      "message": "I removed closed and made Init, Closed singletons that extend state. I left State a base class, because if it would be a trait, it would be something like this:\n\n    private trait State {\n\n        def contexts: ContextMap\n\n        def add(address: SocketAddress, context: ClientContext): State \u003d {\n            val newContexts \u003d new ContextHashMap(contexts)\n            newContexts.put(address, context)\n            new Running(newContexts)\n        }\n\n        def remove(address: SocketAddress): State \u003d {\n            if (contexts.size() \u003d\u003d 1 \u0026\u0026 contexts.containsKey(address)) {\n                Init\n            } else if (contexts.size() \u003d\u003d 0) {\n                this\n            } else {\n                val newContexts \u003d new ContextHashMap(contexts)\n                newContexts.remove(address)\n                new Running(newContexts)\n            }\n        }\n\n        def get(address: SocketAddress): ClientContext \u003d {\n            contexts.get(address)\n        }\n\n        def list: util.Collection[ClientContext] \u003d {\n            contexts.values()\n        }\n    }\n    private class Running(override val contexts: ContextMap) extends State\n    private object Init extends State { override def contexts \u003d Collections.emptyMap() }\n    private object Closed extends State { override def contexts \u003d Collections.emptyMap() }\n\nHowever, I have doubts about the synchronization of the contexts field with this approach: if a thread will see a correctly initialized version of the hashmap (I suspect it will though)",
      "parentUuid": "baa041b7_b0df9639",
      "range": {
        "startLine": 45,
        "startChar": 34,
        "endLine": 45,
        "endChar": 46
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_6d4ffbbe",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T17:16:00Z",
      "side": 1,
      "message": "2 states isn\u0027t really a state machine, especially when they both contain the same state.",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 79,
        "endChar": 5
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_5034cadc",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-28T18:39:37Z",
      "side": 1,
      "message": "These are just 2 singletons representing the initial and final states. Any state in between is just an instance of State with any number of contexts.",
      "parentUuid": "baa041b7_6d4ffbbe",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 79,
        "endChar": 5
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_70e22e03",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 149,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "if you change the hierarchy as I said above, this can turn to using a match, which i think would be cleaner.",
      "range": {
        "startLine": 146,
        "startChar": 12,
        "endLine": 149,
        "endChar": 13
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_394ed1c1",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 149,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-29T09:54:40Z",
      "side": 1,
      "message": "I compare with Closed state now, but used an if though: is more compact and efficient (there\u0027s much less bytecode for an if than for a match).",
      "parentUuid": "baa041b7_70e22e03",
      "range": {
        "startLine": 146,
        "startChar": 12,
        "endLine": 149,
        "endChar": 13
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_50f16acc",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 156,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "what does shutdown mean in this context?",
      "range": {
        "startLine": 156,
        "startChar": 37,
        "endLine": 156,
        "endChar": 45
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_99003d68",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 156,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-29T09:54:40Z",
      "side": 1,
      "message": "This is a new addition: it tells the underlying subscribers via the context where they should close gracefully by sending a completion notification to the client. This is true when close() is initiated by the server, and false when initiated by the client (e.g. on unsubscribe or the netty channel being closed).\n\nThe name is not the best though: changing to `serverInitiated`",
      "parentUuid": "baa041b7_50f16acc",
      "range": {
        "startLine": 156,
        "startChar": 37,
        "endLine": 156,
        "endChar": 45
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_40e2b130",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 156,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-30T13:53:15Z",
      "side": 1,
      "message": "I generally don\u0027t like boolean parameters. It\u0027s usually a hint to split into 2 methods, like closeGracefully() and closeNow()",
      "parentUuid": "baa041b7_99003d68",
      "range": {
        "startLine": 156,
        "startChar": 37,
        "endLine": 156,
        "endChar": 45
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_3015c6e4",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 158,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "break",
      "range": {
        "startLine": 158,
        "startChar": 16,
        "endLine": 158,
        "endChar": 22
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_79d1f9fa",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 158,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-29T09:54:40Z",
      "side": 1,
      "message": "There is no break or continue in scala :/ There is a Breakable class, but I think it\u0027s ugly here.",
      "parentUuid": "baa041b7_3015c6e4",
      "range": {
        "startLine": 158,
        "startChar": 16,
        "endLine": 158,
        "endChar": 22
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_c0f5a1ed",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 158,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-30T13:53:15Z",
      "side": 1,
      "message": "ah, scala sucks sometimes.",
      "parentUuid": "baa041b7_79d1f9fa",
      "range": {
        "startLine": 158,
        "startChar": 16,
        "endLine": 158,
        "endChar": 22
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_30eca6f2",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 178,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T19:51:54Z",
      "side": 1,
      "message": "this could get, null check and close could be encapsulated in the State itself.",
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_39fc913d",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 178,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-29T09:54:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "baa041b7_30eca6f2",
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_4de557a6",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 251,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-06-28T17:16:00Z",
      "side": 1,
      "message": "since this only happens when the state is closed and closed is the terminal state, this here is an infinite loop.",
      "range": {
        "startLine": 251,
        "startChar": 24,
        "endLine": 251,
        "endChar": 54
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_9041323c",
        "filename": "midonet-cluster/src/main/scala/org/midonet/cluster/services/state/StateTableManager.scala",
        "patchSetId": 2
      },
      "lineNbr": 251,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-06-28T18:39:37Z",
      "side": 1,
      "message": "this is thrown when the cache is closed, not the manager (i.e. handles a race to a table cache that is about to close because it\u0027s last subscribe has unsubscribed). the next iteration should create a new cache that doesn\u0027t throw (or it only does if it\u0027s subject to the same concurrent access)",
      "parentUuid": "baa041b7_4de557a6",
      "range": {
        "startLine": 251,
        "startChar": 24,
        "endLine": 251,
        "endChar": 54
      },
      "revId": "d3bc3470c3a450d0f4b34832972b9efb8e7dd369",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}