{
  "comments": [
    {
      "key": {
        "uuid": "facab960_50c14e2d",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "every observer is completable. this is just exposing a flag saying whether it is completed or not. can we add this flag to AwaitableObserver instead?\n\nalso, an observer can be complete by onError.\n\nI also don\u0027t see where this is being used in this patch?",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_375bd955",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "My naming sucks. Regarding AwaitableObserver, even if I added the flag to it, we can\u0027t use it unless we mix it into another class, which can\u0027t be anonymous class extends Observer. We neither can extend the stackable trait, AwaitableObserver, and create an anonymous class directly.",
      "parentUuid": "facab960_50c14e2d",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_be05fdc3",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-26T16:53:34Z",
      "side": 1,
      "message": "i think the solution is not to use an anonymous class then",
      "parentUuid": "facab960_375bd955",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_8f6d5335",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-28T06:40:26Z",
      "side": 1,
      "message": "So do we force users to define classes to use NetlinkRequestBroker with blocking channels? We can have the single class used for every request, say RequestObserver. However, how about the situation we want to consume replies from multiple Observers?\n\nNested Observer causes \"[-2] Message truncated\" because the read buffer is not cleared when onCompleted or onNext are called, so we need to use zip or whatever to coordinate multiple Observables, and therefore we need to use Subjects, which requires us to implement Observable and Observer interfaces, or defined derived classes PublishSubject, which can\u0027t be extended and is not allowed to be instantiated except with the factory method.\n\nhttps://github.com/tfukushima/midonet/blob/rtn-blocking-review-rebase/midolman/src/main/scala/org/midonet/midolman/host/scanner/DefaultInterfaceScanner.scala#L394-L428",
      "parentUuid": "facab960_be05fdc3",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_af8697b7",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-28T07:12:36Z",
      "side": 1,
      "message": "s/derived classes PublishSubject/derived classes such as PublishSubject/\n\nSubject has hasCompleted and hasThrowable methods but they\u0027re marked by @Experimental and we can\u0027t rely on them. If we think they can be used, this problem is solved already.\nhttp://reactivex.io/RxJava/javadoc/rx/subjects/Subject.html#hasCompleted()",
      "parentUuid": "facab960_8f6d5335",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_2fc287e9",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-28T07:31:59Z",
      "side": 1,
      "message": "Ah, maybe we can do like the following although it looks awkward.\n\n        val linkListSubject \u003d PublishSubject.create[Set[Link]]\n        val addrListSubject \u003d PublishSubject.create[Set[Addr]]\n\n        Observable.zip[Set[Link], Set[Addr], Set[InterfaceDescription]](\n            linkListSubject, addrListSubject, makeFunc2((links, addrs) \u003d\u003e {\n                log.debug(\n                    \"Composing the initial state from the retrieved data\")\n                composeIfDesc(links, addrs)\n                log.debug(\"Composed the initial interface descriptions: \",\n                    interfaceDescriptions)\n                filteredIfDescSet\n            })).subscribe(initialScan)\n\n        val linkListRequestObserver \u003d\n            new RequestObserver[Set[Link]] with AwaitableObserver[Set[Link]]\n        linkListSubject.subscribe(linkListRequestObserver)\n        linksList(linkListRequestObserver)\n        while (!linkListRequestObserver.isCompleted) {\n            try {\n                requestBroker.readReply()\n            } catch {\n                case t: Throwable \u003d\u003e\n                    log.error(\"Error happened on reading rtnetlink messages\", t)\n            }\n        }\n        val addrListRequestObserver \u003d\n            new RequestObserver[Set[Addr]] with AwaitableObserver[Set[Addr]]\n        addrListSubject.subscribe(addrListRequestObserver)\n        addrsList(addrListRequestObserver)\n        while (!addrListRequestObserver.isCompleted) {\n            try {\n                requestBroker.readReply()\n            } catch {\n                case t: Throwable \u003d\u003e\n                    log.error(\"Error happened on reading rtnetlink messages\", t)\n            }\n        }\n        log.debug(\"InterfaceScanner has successfully started\")\n    }",
      "parentUuid": "facab960_af8697b7",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_6fbc8f6a",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-28T08:01:43Z",
      "side": 1,
      "message": "Sorry for bothering but I should have passed subjects to the request methods.\n\n        linksList(linkListSubject)\n        ...\n        addrsList(addrListSubject)\n\nAnd I found I could just use RichObserver.\n\n        val linksSubject \u003d PublishSubject.create[Set[Link]]\n        val addrsSubject \u003d PublishSubject.create[Set[Addr]]\n\n        val obs \u003d TestObserver { _: Boolean \u003d\u003e promise.trySuccess(OK) }\n        Observable.zip[Set[Link], Set[Addr], Boolean](\n            linksSubject, addrsSubject, makeFunc2((links, addrs) \u003d\u003e true))\n            .subscribe(obs)\n\n        conn.linksList(linksSubject)\n        val linksListRequestObserver \u003d new RichObservable(linksSubject).asFuture\n        while (!linksListRequestObserver.isCompleted) {\n            try {\n                conn.requestBroker.readReply()\n            } catch {\n                case t: Throwable \u003d\u003e\n                    log.error(\"Error happened on reading rtnetlink messages\", t)\n            }\n        }\n        conn.addrsList(addrsSubject)\n        val addrsListRequestObserver \u003d new RichObservable(addrsSubject).asFuture\n        while (!addrsListRequestObserver.isCompleted) {\n            try {\n                conn.requestBroker.readReply()\n            } catch {\n                case t: Throwable \u003d\u003e\n                    log.error(\"Error happened on reading rtnetlink messages\", t)\n            }\n        }",
      "parentUuid": "facab960_2fc287e9",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_3264aeb8",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-28T09:41:22Z",
      "side": 1,
      "message": "calling toFuture is probably not a good idea since it completes the future on the first call to onNext and since you are dumping, you\u0027ll be expecting multiple onNext calls. so that doesn\u0027t work.\n\nit\u0027s not clear to me what exactly the problem is with the AwaitableObserver. if you want, i\u0027m okay with you using this CompletableClass. just make sure to add a try catch around the call to observer.onCompleted so we call onError and to set completed to true on onError, and also hold on to the exception so we can report errors.",
      "parentUuid": "facab960_6fbc8f6a",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_9272da7a",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-28T09:41:22Z",
      "side": 1,
      "message": "I don\u0027t understand the nested observers problem. It\u0027s all synchronous, so the contents of the bytebuffer are unchanged.",
      "parentUuid": "facab960_8f6d5335",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_014e726f",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-29T10:41:39Z",
      "side": 1,
      "message": "I we want to have two rtnetlink resources, we need to make another request after the first request. And their coordination would be done with zip or other methods of Observable or without them having the nested request in onCompleted or onNext of the observer for the first request.\n\n  val linkListObserver \u003d new Observer[Set[List]] {\n    ...\n    override def onCompleted(): Unit \u003d {\n      val addrsListObserver \u003d new Obsrever[Set[Addr]] {\n        ...\n      }\n      addrsList(addrsListObserver)\n      val addrsListRequestObserver \u003d ...\n      while (addrListRequestObserver.isCompleted) {\n              try {\n                  requestBroker.readReply()\n              } catch {\n                  case t: Throwable \u003d\u003e\n                      log.error(\"Error happened on reading rtnetlink messages\", t)\n              }\n          }\n    }\nHowerver, onCompleted is called before the read buffer is cleared and the request broker tries to read with the uncleared buffer, which causes MessageTruncated and that was what what I got.\n\nhttps://github.com/midonet/midonet/blob/master/netlink/src/main/scala/org.midonet.netlink/NetlinkRequestBroker.scala#L255\nhttps://github.com/midonet/midonet/blob/master/netlink/src/main/scala/org.midonet.netlink/NetlinkRequestBroker.scala#L295\nhttps://github.com/midonet/midonet/blob/master/netlink/src/main/scala/org.midonet.netlink/NetlinkRequestBroker.scala#L268",
      "parentUuid": "facab960_9272da7a",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_8677f8d3",
        "filename": "midonet-util/src/main/scala/org/midonet/util/reactivex/CompletableObserver.scala",
        "patchSetId": 17
      },
      "lineNbr": 25,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-29T10:41:39Z",
      "side": 1,
      "message": "Ah, it\u0027s true RichObserver is no appropriate here. And I found it\u0027s better to have an Observer to subscribe Subjects.\nhttps://github.com/ReactiveX/RxJava/issues/1313",
      "parentUuid": "facab960_3264aeb8",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_7004927e",
        "filename": "netlink/src/main/java/org/midonet/netlink/NetlinkMessage.java",
        "patchSetId": 17
      },
      "lineNbr": 299,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "the comment says this iterates over a bytebuffer containing a sequene of nested netlink attributes, but there\u0027s no iteration, you just scan the first. what\u0027s the difference from scanAttributes?",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_f7409158",
        "filename": "netlink/src/main/java/org/midonet/netlink/NetlinkMessage.java",
        "patchSetId": 17
      },
      "lineNbr": 299,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "It doesn\u0027t iterate over a bytebuffer and just scan the single nested attribute. I fixed the comment.",
      "parentUuid": "facab960_7004927e",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_d0039e71",
        "filename": "netlink/src/main/java/org/midonet/netlink/NetlinkNotificationReader.scala",
        "patchSetId": 17
      },
      "lineNbr": 31,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "a lot of my previous comments to this class still apply. this shouldn\u0027t be a trait, we shouldn\u0027t have lazy fields, and we shouldn\u0027t create the thread explicitly.",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_3a22e0b9",
        "filename": "netlink/src/main/java/org/midonet/netlink/NetlinkNotificationReader.scala",
        "patchSetId": 17
      },
      "lineNbr": 31,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "Why should we avoid lazy so much and why should NetlinkNotificationReader be a class? And if we should not create a thread, which would be repeatedly done for every blocking notification reader,  I don\u0027t think we need this trait and we can just repeatedly define them manually.",
      "parentUuid": "facab960_d0039e71",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_9e0039ac",
        "filename": "netlink/src/main/java/org/midonet/netlink/NetlinkNotificationReader.scala",
        "patchSetId": 17
      },
      "lineNbr": 31,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-26T16:53:34Z",
      "side": 1,
      "message": "a) we can mix this trait into a class where we want to use an existing thread to process notifications\nb) lazy require a volatile read every time. it\u0027s also forcing implementers to declare lazy fields, just to satisfy the compiler. i know this is only lazy to solve compilation problems, not because of actual design, so i think it\u0027s a code smell, since there are other ways to solve the compilation problems: make this a class (preferable) or use scala\u0027s early initializers.",
      "parentUuid": "facab960_3a22e0b9",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_50ef8eb0",
        "filename": "netlink/src/main/java/org/midonet/netlink/NetlinkNotificationReader.scala",
        "patchSetId": 17
      },
      "lineNbr": 64,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "the observer expects the whole netlink header to be in the buffer?\nalso, this is wrong, we\u0027re always passing the first message if the buffer contains multiple ones.",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_90303658",
        "filename": "netlink/src/main/java/org/midonet/netlink/rtnetlink/Neigh.java",
        "patchSetId": 17
      },
      "lineNbr": 164,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "how can there be a buffer overflow if we checked before buf.remaining?",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_ba87d060",
        "filename": "netlink/src/main/java/org/midonet/netlink/rtnetlink/Neigh.java",
        "patchSetId": 17
      },
      "lineNbr": 164,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "facab960_90303658",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_f03ee228",
        "filename": "netlink/src/main/scala/org.midonet.netlink/GenlProtocol.scala",
        "patchSetId": 17
      },
      "lineNbr": 30,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "can we get rid of the explicit type?  it looked better before :)",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_9a268cb9",
        "filename": "netlink/src/main/scala/org.midonet.netlink/GenlProtocol.scala",
        "patchSetId": 17
      },
      "lineNbr": 30,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "facab960_f03ee228",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_103c262f",
        "filename": "netlink/src/main/scala/org.midonet.netlink/NetlinkChannelFactory.scala",
        "patchSetId": 17
      },
      "lineNbr": 36,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "it doesn\u0027t seem right that the default notification case uses the ovs groups.\n\ncan\u0027t we simply pass in the notification group as an argument to the method?",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_2d5b8855",
        "filename": "netlink/src/main/scala/org.midonet.netlink/NetlinkChannelFactory.scala",
        "patchSetId": 17
      },
      "lineNbr": 36,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "facab960_103c262f",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_501dcebc",
        "filename": "netlink/src/main/scala/org.midonet.netlink/NetlinkUtil.scala",
        "patchSetId": 17
      },
      "lineNbr": 53,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "is this being used? i don\u0027t like it, it allocates an object. we should use dead-reckoning to retrieve the values we\u0027re interested in.",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_5a3404de",
        "filename": "netlink/src/main/scala/org.midonet.netlink/NetlinkUtil.scala",
        "patchSetId": 17
      },
      "lineNbr": 53,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "facab960_501dcebc",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_d0b55ece",
        "filename": "netlink/src/main/scala/org.midonet.netlink/rtnetlink/RtnetlinkConnection.scala",
        "patchSetId": 17
      },
      "lineNbr": 232,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "this grabs a sequence, but doSendRetryRequest grabs another sequence. this doesn\u0027t seem correct.\n\nseriously, can we get rid of this class?",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_2d79c82f",
        "filename": "netlink/src/main/scala/org.midonet.netlink/rtnetlink/RtnetlinkConnection.scala",
        "patchSetId": 17
      },
      "lineNbr": 232,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "facab960_d0b55ece",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_f0c9825b",
        "filename": "netlink/src/test/scala/org/midonet/netlink/MockBufferPool.scala",
        "patchSetId": 17
      },
      "lineNbr": 37,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "why do we need this?",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_3a3e60b9",
        "filename": "netlink/src/test/scala/org/midonet/netlink/MockBufferPool.scala",
        "patchSetId": 17
      },
      "lineNbr": 37,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "BufferPool provides a set of DirectByteBuffer and we can\u0027t inspect the content of ByteBuffer written by NetlinkRequestBroker.",
      "parentUuid": "facab960_f0c9825b",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_1e1509f1",
        "filename": "netlink/src/test/scala/org/midonet/netlink/MockBufferPool.scala",
        "patchSetId": 17
      },
      "lineNbr": 37,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-26T16:53:34Z",
      "side": 1,
      "message": "but the NetlinkRequestBroker doesn\u0027t use the BufferPool. The buffer pool is for all purposes deprecated.",
      "parentUuid": "facab960_3a3e60b9",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_41587a32",
        "filename": "netlink/src/test/scala/org/midonet/netlink/MockBufferPool.scala",
        "patchSetId": 17
      },
      "lineNbr": 37,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-29T10:41:39Z",
      "side": 1,
      "message": "Oh, that\u0027s true. I\u0027m deleting this file.",
      "parentUuid": "facab960_1e1509f1",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_5074eefc",
        "filename": "netlink/src/test/scala/org/midonet/netlink/rtnetlink/LinkTest.scala",
        "patchSetId": 17
      },
      "lineNbr": 101,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-22T10:29:07Z",
      "side": 1,
      "message": "wow.hardcoded bytes? this is totally unmaintainable :/",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_5a4b2459",
        "filename": "netlink/src/test/scala/org/midonet/netlink/rtnetlink/LinkTest.scala",
        "patchSetId": 17
      },
      "lineNbr": 101,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-25T15:34:45Z",
      "side": 1,
      "message": "Yes, but this is the real data and we can\u0027t check if the deserializer works without it.",
      "parentUuid": "facab960_5074eefc",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_3ef9edc8",
        "filename": "netlink/src/test/scala/org/midonet/netlink/rtnetlink/LinkTest.scala",
        "patchSetId": 17
      },
      "lineNbr": 101,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-05-26T16:53:34Z",
      "side": 1,
      "message": "that should be solved in integration tests. if you want to unit tests, we can try to serialize something, deserialize it back and then compare with the original.",
      "parentUuid": "facab960_5a4b2459",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "facab960_615d7e21",
        "filename": "netlink/src/test/scala/org/midonet/netlink/rtnetlink/LinkTest.scala",
        "patchSetId": 17
      },
      "lineNbr": 101,
      "author": {
        "id": 1002743
      },
      "writtenOn": "2015-05-29T10:41:39Z",
      "side": 1,
      "message": "Unfortunately we don\u0027t have serialize methods for rtnetlink resources. We should have though. I\u0027ll temporarily delete this file.",
      "parentUuid": "facab960_3ef9edc8",
      "revId": "4fd01bc30bacadea3f3eaf0c14de6604beeb4f87",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}