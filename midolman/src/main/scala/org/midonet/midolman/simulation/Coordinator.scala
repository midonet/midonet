/*
 * Copyright 2014 Midokura SARL
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.midonet.midolman.simulation

import java.util
import java.util.UUID

import scala.collection.JavaConversions._
import akka.actor.ActorSystem

import org.midonet.midolman.PacketWorkflow
import org.midonet.midolman.PacketWorkflow.{SimulationResult => Result}
import org.midonet.midolman.PacketWorkflow._
import org.midonet.midolman.rules.RuleResult
import org.midonet.midolman.simulation.Icmp.IPv4Icmp._
import org.midonet.midolman.topology.VirtualTopologyActor._
import org.midonet.odp.FlowMatch
import org.midonet.sdn.flows.VirtualActions.VirtualFlowAction

object Coordinator {
    val MAX_DEVICES_TRAVERSED = 12

    sealed trait ForwardAction extends Result
    case class ToPortAction(outPort: UUID) extends ForwardAction with VirtualFlowAction


    // This action is used when one simulation has to return N forward actions
    // A good example is when a bridge that has a vlan id set receives a
    // broadcast from the virtual network. It will output it to all its
    // materialized ports and to the logical port that connects it to the VAB
    case class ForkAction(first: Result, second: Result) extends ForwardAction

    trait Device {

        /**
         * Process a packet described by the given match object. Note that the
         * Ethernet packet is the one originally ingressed the virtual network
         * - it does not reflect the changes made by other devices' handling of
         * the packet (whereas the match object does).
         *
         * @param pktContext The context for the simulation of this packet's
         * traversal of the virtual network. Use the context to subscribe
         * for notifications on the removal of any resulting flows, or to tag
         * any resulting flows for indexing.
         * @return An instance of Action that reflects what the device would do
         * after handling this packet (e.g. drop it, consume it, forward it).
         */
        def process(pktContext: PacketContext): Result
    }

    /* Keep a pool of MAX_DEVICES*2 FlowMatch instances to support that many
     * nested simulation forks (sequential forks are unlimited) with no
     * extra allocations.
     *
     * The number is generous enough that we'll simply assume the pool never is
     * empty. Should it be not, the affected packet won't make it through.
     */
    private val flowMatchPool = new ThreadLocal[util.ArrayList[FlowMatch]] {
        override def initialValue = {
            val l = new util.ArrayList[FlowMatch](MAX_DEVICES_TRAVERSED*2)
            for (i <- 1 to MAX_DEVICES_TRAVERSED*2) {
                l.add(new FlowMatch())
            }
            l
        }
    }

    private def matchPool = flowMatchPool.get()

    private def popMatch(): FlowMatch = {
        matchPool.remove(matchPool.size()-1)
    }

    private def pushMatch(m: FlowMatch): Unit = {
        matchPool.add(m)
    }
}

/**
 * Coordinator object to simulate one packet traversing the virtual network.
 */
class Coordinator(context: PacketContext)
                 (implicit val actorSystem: ActorSystem) {

    import org.midonet.midolman.simulation.Coordinator._

    implicit val logPktCtx: PacketContext = context
    implicit val log = context.log

    // Used to detect loops: devices simulated (with duplicates).
    private var numDevicesSimulated = 0

    /**
     * Simulate the packet moving through the virtual topology. The packet
     * begins its journey through the virtual topology in one of these ways:
     * 1) it ingresses an exterior port of a virtual device (in which case the
     * packet arrives via the datapath switch from an entity outside the
     * virtual topology).
     * 2) it egresses an interior port of a virtual device (in which case the
     * packet was generated by that virtual device).
     *
     * In case 1, the match object for the packet was computed by the
     * FlowController and must contain an inPortID. If a wildcard flow is
     * eventually installed in the FlowController, the match will be a subset
     * of the match originally provided to the simulation. Note that in this
     * case the generatedPacketEgressPort argument should be null and will be
     * ignored.
     *
     * In case 2, the match object for the packet was computed by the Device
     * that emitted the packet and must not contain an inPortID. If the packet
     * is not dropped, it will eventually result in a packet being emitted
     * from one or more of the datapath ports. However, a flow is never
     * installed as a result of such a simulation. Note that in this case the
     * generatedPacketEgressPort argument must not be null.
     *
     * When the future returned by this method completes all the actions
     * resulting from the simulation (install flow and/or execute packet)
     * have been completed.
     *
     * The resulting future is never in a failed state.
     */
    def simulate(): Result = {
        log.debug("Simulating a packet")
        if (context.ingressed) {
            packetIngressesPort(context.inputPort, getPortGroups = true)
        } else {
            packetEgressesPort(context.egressPort)
        }
    }

    private def packetIngressesDevice(port: Port): Result = {
        val device = port match {
            case _: BridgePort => tryAsk[Bridge](port.deviceId)
            case _: VxLanPort => tryAsk[Bridge](port.deviceId)
            case _: RouterPort => tryAsk[Router](port.deviceId)
        }
        numDevicesSimulated += 1
        log.debug(s"packet ingresses port: ${port.id} at device ${port.deviceId}")
        handleAction(device.process(context))
    }


    private def merge(a: Result, b: Result) : Result = {
        val result = (a, b) match {
            case (PacketWorkflow.Drop, action) => action
            case (action, PacketWorkflow.Drop) => action

            case (PacketWorkflow.ErrorDrop, _) => ErrorDrop
            case (_, PacketWorkflow.ErrorDrop) => ErrorDrop

            case (firstAction, secondAction) =>
                val clazz1 = firstAction.getClass
                val clazz2 = secondAction.getClass
                if (clazz1 != clazz2) {
                    log.error("Matching actions of different types {} & {}!",
                        clazz1, clazz2)
                }
                firstAction
        }
        log.debug(s"Forked action merged results $result")
        result
    }

    private def branch(result: Result): Result = {
        val branchPoint = popMatch()
        try {
            branchPoint.reset(context.wcmatch)
            handleAction(result)
        } finally {
            context.wcmatch.reset(branchPoint)
            pushMatch(branchPoint)
        }
    }

    private def handleAction(simRes: Result): Result = simRes match {
        case ForkAction(first, second) =>      merge(branch(first), branch(second))
        case ToPortAction(outPortID) =>        packetEgressesPort(outPortID)
        case res => res
    }

    private def packetIngressesPort(portID: UUID, getPortGroups: Boolean) : Result =
        // Avoid loops - simulate at most X devices.
        if (numDevicesSimulated >= MAX_DEVICES_TRAVERSED) {
            ErrorDrop
        } else {
            val port = tryAsk[Port](portID)
            context.addFlowTag(port.deviceTag)
            context.addFlowTag(port.rxTag)
            port match {
                case p if !p.adminStateUp =>
                    processAdminStateDown(p, isIngress = true)
                case p =>
                    if (getPortGroups && p.isExterior) {
                        context.portGroups = p.portGroups
                    }
                    context.inPortId = portID
                    applyPortFilter(p, p.inboundFilter, packetIngressesDevice)
            }
        }

    private def applyPortFilter(port: Port, filterID: UUID, thunk: (Port) => Result): Result = {
        if (filterID == null)
            return thunk(port)

        val chain = tryAsk[Chain](filterID)
        val result = Chain.apply(chain, context, port.id, true)
        result.action match {
            case RuleResult.Action.ACCEPT =>
                thunk(port)
            case RuleResult.Action.DROP | RuleResult.Action.REJECT =>
                Drop
            case other =>
                log.error("Port filter {} returned {} which was " +
                        "not ACCEPT, DROP or REJECT.", filterID, other)
                ErrorDrop
        }
    }

    private def handleVlanEgress(port: Port): Unit = port match {
        case bp: BridgePort if bp.vlanId > 0 && context.wcmatch.isVlanTagged =>
            context.wcmatch.removeVlanId(bp.vlanId)
        case _ =>
    }

    /**
     * Simulate the packet egressing a virtual port. This is NOT intended
     * for flooding bridges
     */
    private def packetEgressesPort(portID: UUID): Result = {
        val port = tryAsk[Port](portID)
        context.addFlowTag(port.deviceTag)
        context.addFlowTag(port.txTag)

        port match {
            case p if !p.adminStateUp =>
                processAdminStateDown(p, isIngress = false)
            case p if p.id == context.inPortId && p.isInstanceOf[BridgePort] =>
                Drop
            case p =>
                /* TODO(guillermo) the port itself should process the packet and
                 * do both the filtering and VLAN (un)tagging. */
                handleVlanEgress(p)
                context.outPortId = p.id
                applyPortFilter(p, p.outboundFilter, {
                    case p: Port if p.isExterior =>
                        emitFromPort(p)
                    case p: Port if p.isInterior =>
                        packetIngressesPort(p.peerId, getPortGroups = false)
                    case _ =>
                        log.warn("Port {} is unplugged", portID)
                        ErrorDrop
                })
        }
    }

    private def emitFromPort(port: Port): Result = {
        context.calculateActionsFromMatchDiff()
        log.debug("Emitting packet from vport {}", port.id)
        context.addVirtualAction(port.action)
        emit(port.deviceId)
    }

    private def emit(deviceId: UUID): Result = {
        context.trackConnection(deviceId)
        context.addTraceKeysForEgress()
        AddVirtualWildcardFlow
    }

    private[this] def processAdminStateDown(port: Port, isIngress: Boolean): Result = {
        port match {
            case p: RouterPort if isIngress =>
                sendIcmpProhibited(p)
            case p: RouterPort if context.inPortId != null =>
                tryAsk[Port](context.inPortId) match {
                    case p: RouterPort =>
                        sendIcmpProhibited(p)
                    case _ =>
                }
            case _ =>
        }

        Drop
    }

    private def sendIcmpProhibited(port: RouterPort): Unit = {
        val ethOpt = unreachableProhibitedIcmp(port, context)
        if (ethOpt.isDefined) {
            context.addGeneratedPacket(port.id, ethOpt.get)
        }
    }
}
