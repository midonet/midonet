{
  "comments": [
    {
      "key": {
        "uuid": "fafc7978_f5584bfc",
        "filename": "cluster/src/main/scala/org/midonet/cluster/data/storage/SubscriptionCache.scala",
        "patchSetId": 10
      },
      "lineNbr": 75,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-02T09:18:29Z",
      "side": 1,
      "message": "\"...will just call onError ...\" ?",
      "range": {
        "startLine": 75,
        "startChar": 19,
        "endLine": 75,
        "endChar": 36
      },
      "revId": "c68a11fcb4cdd3f31d1cf5c950730c927ec2c084",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_75557bc5",
        "filename": "cluster/src/main/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapper.scala",
        "patchSetId": 10
      },
      "lineNbr": 161,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-02T09:18:29Z",
      "side": 1,
      "message": "By removing the read lock you, some caches may never be gc\u0027ed. Was that done on purpose? The scenario is the following:\n\n        /*\n         * We obtain a read lock on instanceCacheRWLock to prevent\n         * the following undesired scenario from occurring:\n         *  -A cache has no subscriber and is added to the set\n         *   of caches to gc.\n         *  -Before the gc kicks in, the cache gets a subscriber.\n         *  -As a consequence the cache is not closed by the gc.\n         *  -Before instanceCachesToGc is cleared by the gc,\n         *   the subscriber unsubscribes.\n         *  -The gc clears instanceCachesToGc.\n         *\n         * As a consequence the cache may never be closed.\n         */",
      "range": {
        "startLine": 161,
        "startChar": 8,
        "endLine": 161,
        "endChar": 43
      },
      "revId": "c68a11fcb4cdd3f31d1cf5c950730c927ec2c084",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_b837daaf",
        "filename": "cluster/src/main/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapper.scala",
        "patchSetId": 10
      },
      "lineNbr": 161,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2014-12-02T14:51:07Z",
      "side": 1,
      "message": "I think this is a justified concern. However, do the lists of GC-able caches have to be TrieMap at all, forcing us to iterate over the collection and then clear them? Since we only write to these lists when the last subscriber disconnects, and only ready during GC, why not use a concurrent queue or something similar?\n\nIf for example:\n\n  private val cacheToGc \u003d new ConcurrentLinkedQueue[SubscriptionCache[_]]\n\nThen adding to the GC collection becomes:\n\n  cacheToGc.add(cache)\n\nAnd GC becomes:\n\n        var cache: InstanceSubscriptionCache[_] \u003d null\n        do {\n            cache \u003d cacheToGc.poll()\n            if ((cache ne null) \u0026\u0026 cache.closeIfNeeded()) {\n                instanceCaches(cache.clazz).remove(cache.id)\n            }\n        } while (cache ne null)\n\nTo prevent adding a cache to the collection, each cache can maintain a val isGcAble: Boolean \u003d true. When adding this to the GC list, we set this to false, when the cache is garbage collected with closeIfNeeded, we set it to true.",
      "parentUuid": "fafc7978_75557bc5",
      "range": {
        "startLine": 161,
        "startChar": 8,
        "endLine": 161,
        "endChar": 43
      },
      "revId": "c68a11fcb4cdd3f31d1cf5c950730c927ec2c084",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_5552f7dd",
        "filename": "cluster/src/main/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapper.scala",
        "patchSetId": 10
      },
      "lineNbr": 170,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-02T09:18:29Z",
      "side": 1,
      "message": "Same comment as above.",
      "range": {
        "startLine": 170,
        "startChar": 7,
        "endLine": 170,
        "endChar": 40
      },
      "revId": "c68a11fcb4cdd3f31d1cf5c950730c927ec2c084",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_f5268b67",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservablePathChildrenCache.scala",
        "patchSetId": 10
      },
      "lineNbr": 132,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-02T09:18:29Z",
      "side": 1,
      "message": "The lock part of Brandon\u0027s comment has been addressed, what about the rest?",
      "range": {
        "startLine": 132,
        "startChar": 12,
        "endLine": 132,
        "endChar": 37
      },
      "revId": "c68a11fcb4cdd3f31d1cf5c950730c927ec2c084",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_f5ddeb43",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservablePathChildrenCache.scala",
        "patchSetId": 10
      },
      "lineNbr": 174,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-02T09:18:29Z",
      "side": 1,
      "message": "extra blank line",
      "range": {
        "startLine": 172,
        "startChar": 0,
        "endLine": 174,
        "endChar": 1
      },
      "revId": "c68a11fcb4cdd3f31d1cf5c950730c927ec2c084",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}