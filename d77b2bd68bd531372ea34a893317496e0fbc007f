{
  "comments": [
    {
      "key": {
        "uuid": "fa2559ec_479b81c9",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "Could this be defined as a case class rather than a typedef, so that you can give the fields names?",
      "range": {
        "startLine": 47,
        "startChar": 4,
        "endLine": 47,
        "endChar": 34
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa2559ec_076229d8",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 72,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "Returning a Boolean provides no information if you never return false. You can just change the return type to Unit.",
      "range": {
        "startLine": 72,
        "startChar": 22,
        "endLine": 72,
        "endChar": 29
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa2559ec_87f3b909",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 79,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "By convention, non-mutating methods with no arguments omit the empty parentheses.",
      "range": {
        "startLine": 79,
        "startChar": 12,
        "endLine": 79,
        "endChar": 14
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa2559ec_e75ef511",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 90,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "I believe the more idiomatic way to express this is peek.getOrElse(throw new NotInBufferException)",
      "range": {
        "startLine": 87,
        "startChar": 4,
        "endLine": 90,
        "endChar": 5
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa2559ec_87a57906",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 103,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "You can reuse peek here:\n\nval item \u003d peek()\nitem.foreach(rd.lazySet(rdPos + 1))\nitem\n\nIf there\u0027s not a good perf reason to keep it as is, I mean. This does add an extra branch, so maybe it\u0027s better to leave as is.",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 103,
        "endChar": 9
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa2559ec_a7ab5dd5",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 109,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "poll().getOrElse(throwNewBufferEmptyException)",
      "range": {
        "startLine": 106,
        "startChar": 34,
        "endLine": 109,
        "endChar": 5
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa2559ec_47d0a153",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "If I\u0027m understanding the code, it\u0027s possible to both rewind and offer to fail due to a race condition, right? That is, we roll back rd to wrIntent - capacity. That should be fine, since it exactly fills the buffer, but then before we do the check, offer comes along, increments wrIntent, checks the capacity, and fails. But before wrIntent gets set back to its old value, the capacity check here fails.\n\nIs that what the comment is talking about? All it mentions is that offer can return buffer full, which is obviously the case if you\u0027re rolling back as far as possible. The interesting part is that they both fail.",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 123,
        "endChar": 31
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa2559ec_470541c1",
        "filename": "midonet-util/src/main/scala/org/midonet/util/concurrent/SpscRwdRingBuffer.scala",
        "patchSetId": 6
      },
      "lineNbr": 157,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2015-01-15T10:58:31Z",
      "side": 1,
      "message": "This looks like it should be vulnerable to an ABA error, but maybe it doesn\u0027t matter.\n\nSuppose we read rdPos at 5/10/5 (rd/wr/size), then an offer() call happens and wr advances, and a poll() call happens and rd advances. Then we read wr at 6/11/5. Then another offer takes it to 6/12/6. Then rewind sets rd back to 5, and we\u0027re at 5/12/7. The rdPos \u003d\u003d rd.get() check passes, so we return 6 (11 - 5). So that\u0027s wrong.\n\nBut maybe it doesn\u0027t matter. The size can change at any time, and even if we can guarantee that size returns the actual size at that moment, we can\u0027t guarantee that nothing happens between when the caller calls size and when the caller tries to do something with that information. The size was 6 at some point in the recent past; is that good enough?",
      "range": {
        "startLine": 154,
        "startChar": 1,
        "endLine": 157,
        "endChar": 9
      },
      "revId": "d77b2bd68bd531372ea34a893317496e0fbc007f",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}