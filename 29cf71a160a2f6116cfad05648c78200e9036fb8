{
  "comments": [
    {
      "key": {
        "uuid": "baa041b7_129251f6",
        "filename": "midolman/src/main/scala/org/midonet/midolman/HostRequestProxy.scala",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-07-29T15:30:23Z",
      "side": 1,
      "message": "You\u0027re ignoring the first future. User either a andThen if the loads should be in sequence of Future.sequence if you allow then in parallel.",
      "range": {
        "startLine": 258,
        "startChar": 16,
        "endLine": 259,
        "endChar": 60
      },
      "revId": "29cf71a160a2f6116cfad05648c78200e9036fb8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_52b33998",
        "filename": "midolman/src/main/scala/org/midonet/midolman/HostRequestProxy.scala",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 1003318
      },
      "writtenOn": "2016-07-29T15:38:14Z",
      "side": 1,
      "message": "There\u0027s something I dont\u0027 understand. If we were ignoring the first future, the compatibility test would have failed (as it wouldn\u0027t have loaded the flow state from storage). But it passed. I thought that specifying the andThen inside stateForPorts already creates the callback to process the result of the future.",
      "parentUuid": "baa041b7_129251f6",
      "range": {
        "startLine": 258,
        "startChar": 16,
        "endLine": 259,
        "endChar": 60
      },
      "revId": "29cf71a160a2f6116cfad05648c78200e9036fb8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_72451d6d",
        "filename": "midolman/src/main/scala/org/midonet/midolman/HostRequestProxy.scala",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2016-07-29T15:47:09Z",
      "side": 1,
      "message": "I didn\u0027t mean that the future won\u0027t complete and the code won\u0027t execute. I meant that we\u0027re using the conveyor belt to serialize the fetching of the flowState wrt to port changes. If you ignore the first future that serialization won\u0027t happen because the belt will move to the next tasks without waiting for the previous ones to complete.\n\nI assume this serialization is needed?",
      "parentUuid": "baa041b7_52b33998",
      "range": {
        "startLine": 258,
        "startChar": 16,
        "endLine": 259,
        "endChar": 60
      },
      "revId": "29cf71a160a2f6116cfad05648c78200e9036fb8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_322315bf",
        "filename": "midolman/src/main/scala/org/midonet/midolman/HostRequestProxy.scala",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 1003318
      },
      "writtenOn": "2016-07-29T15:51:30Z",
      "side": 1,
      "message": "ah I see now. Didn\u0027t notice that the belt was waiting on the returned future. I\u0027ll fix this patch and push a patch for the 5.2.",
      "parentUuid": "baa041b7_72451d6d",
      "range": {
        "startLine": 258,
        "startChar": 16,
        "endLine": 259,
        "endChar": 60
      },
      "revId": "29cf71a160a2f6116cfad05648c78200e9036fb8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}