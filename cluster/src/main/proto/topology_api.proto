// This file requests that any client of the Midonet cluster may issue
// to gain access to objects stored in the internal Midonet storage
import "commons.proto";
import "topology.proto";

package org.midonet.cluster.models;

option java_package = "org.midonet.cluster.rpc";
option java_outer_classname = "Commands";

// ------------------ MIDONET STORAGE API -----------------------------

//
// PROTOCOL
//
// The Midonet Storage API protocol defines the exchange of message between
// a Midonet topology client and the Midonet topology service. The data
// exchaged used the protobuf format; requests from the client consist
// of "Request" messages, and the responses from the server consist of
// "Response" messages - any particular type of information is encapsulated
// inside these two wrapper message types.
//
// This protocol becomes active when a low level communication channel has
// been established (e.g. a plain socket connection or a websocket connection).
// The protocol has three main states:
//   - Ready: this is the initial state. It transitions to Active after a
//       successful handshake, or to Closed after a network disconnection
//   - Active: this is the main state where the subscribe/unsubscribe
//       commands are accepted. It transitions to Closed after receiving
//       a 'Bye' command or after a network disconnection
//   - Closed: the connection is closed and more requests are accepted
//
// Common principles:
// -----------------
// All request commands have a compulsory req_id field. This id must be
// generated by the client and its only purpose is to be able to associate a
// particular request with its corresponding Ack or Nack responses.
//
// Hanshake procedure:
// ------------------
// The client should send a HandShake command inside a "Request" message.
// The 'cnxn_id' field must be generated by the client and will be used
// to identify a set of subscriptions. A client can recover a severed
// connection by sending the same cnxn_id in the new HandShake command (unless
// the disconnection was due to an explicit 'Bye' command).
// After sending the HandShake command, the client may receive:
//   - A "Response" message containing an "Ack", if the handshake was
//       successful.
//   - A "Response" message containing a "NAck", if the handshake failed. The
//       most likely reason for failure is specifying a cnxn_id that is already
//       in use from another connection; in this case, the client may retry
//       specifying a different cnxn_id in the HandShake command.
//
// Getting data, subscribing and unsubscribing:
// -------------------------------------------
// Getting data about an entity, and optionally subscribing to receive
// further updates, is done by sending a "Request" message containing a
// "Get" command. Apart from the compulsory 'req_id', the "Get" command
// must contain the type of the entity (or entities) to retrieve and,
// optionally, the following fields:
//   - id: the id of the entity to retrieve (if not present, all the entities
//     of the given type will be retrieved).
//   - subscribe: a boolean indicating if further updates about entity
//     modifications are to be received (if not present or false, only the
//     current state will be send). Note that, if no id is specified, new
//     objects of the given type will also be reported upon creation.
// After sending the Get command, the client may receive:
//   - A "Response" message containing a "Nack", if the Get request was
//     unsuccessful (e.g. trying to get data about a non-existing id).
//   - One or more "Response" messages containing either "Update" or "Deletion"
//     responses, corresponding to the requested items.
// Note that subscriptions are idempotent: multiple subscriptions on the same
// entities do not result in multiple copies of the updates.
//
// A subscription can be revoked with a "Request" message containing an
// "Unsubscribe" command. Apart from the compulsory "req_id" and "type"
// fields, the command may optionally contain the id of the entity to forget
// about. If no id is specified, then the global per-type subscription will
// be cancelled (if any).
// After sending the Unsubscribe command, the client may receive:
//   - A "Response" message containing an "Ack", if the unsubscribe was
//       successful.
//   - A "Response" message containing a "NAck", if the unsubscribe failed.
//
// Termination:
// -----------
// A client can gracefully terminate the connection by issuing a "Request"
// message containing a "Bye" request. This request cancels all existing
// subscriptions for that client and terminates the session.
// Note that a session terminated with a "Bye" request cannot be resumed
// in a new connection.
// After sending the "Bye" command, the client will receive
//   - A "Response" message containing an "Ack", indicating that the
//       termination command has been processed by the server.
// After sending the Bye Ack message, the server may or may not terminate
// the connection. In any case, it is safe for the client to disconnect
// after receiving the Ack.
//



// Used to accommodate different types of ids for different types of topology
// entities.
message ID {
    oneof id {
        string name = 1;
        UUID uuid = 2;
        string strId = 3; // Vteps have string ids
    }
}

// Used by clients to communicate commands to the cluster serving the
// Midonet topology. The first message after opening the connection must
// be a HANDSHAKE, followed by any number of GET, SUB, or UNSUB
// requests. A BYE message should be sent to the cluster to signal that
// the client is no longer interested in keeping the connection alive
// and its subscritions can be ignored. If this message is not sent, the
// cluster will assume a partition and try to remember the subscriptions
// from this client.
message Request {
    message Handshake {
        required UUID req_id = 1;         // Request id
        required UUID cnxn_id = 2;        // Connection identifier (session)
        optional int64 seqno = 3;         // Last seen session sequence number
                                          // (for session recovery)
        optional string last_tx_id = 4;   // Last heard from the cluster,
                                          // if set, the cluster will
                                          // try to resend missed
                                          // updates
    }
    message Get { // Ask the cluster to provide the given entities
        required UUID req_id = 1;               // Request id
        required Type type = 2;                 // Entities of this type..
        optional ID id = 3;                     // .. and id (which MUST
                                                // match the format for the
                                                // specific Topology.Type)
        optional bool subscribe = 4;            // .. and subscribe
    }
    message Unsubscribe { // Tell cluster to NOT send updates about it
        required UUID req_id = 1;        // Request id
        required Type type = 2;          // Type of the entity
        optional ID id = 3;              // Id of the entity, if not
                                         // set, all the objects of type;
                                         // Must match the format for the
                                         // specific Topology.Type
    }
    message Bye {   // Tell the cluster we're dropping the cnxn
        required UUID req_id = 1;
    }
    oneof request {
        string name = 1;
        Handshake handshake = 2;      // Connect to the cluster
        Get get = 3;                  // Subscribe to some entities
        Unsubscribe unsubscribe = 4;  // Unsubscribe from some entities
        Bye bye = 5;                  // Disconnect from the cluster
    }
}

// Sent from the cluster to clients in response to Request messages:
// - Handshake: will be replied with an ACK/REJECT. If ACK, it will
//              include an identifier of the connection.
// - Data: will be replied with the latest known copy of the requested
//         entities for the cluster node that the client is connected to.
//         If the request was a subscription, it'll be followed by a new
//         copy of the data every time that the cluster becomes aware of
//         a change in the entity (including deletions).
// - Bye: not replied, the client can consider it a fire-and-forget
message Response {
    message Ack {      // acknowledge request req_id
        required UUID req_id = 1;  // Id of the request we're ack'ing
    }
    message NAck {      // don't acknowledge request req_id
        required UUID req_id = 1; // Id of the request we're ack'ing
    }
    message Deletion { // entity with the given id/type is no more
        required int64 seqno = 1 [default = 0]; // Session sequence number
        required ID id = 2; // MUST match the id format for the Topology.Type
        required Type type = 3;
    }
    message Update {          // the latest known state of an entity
        required int64 seqno = 1 [default = 0]; // Session sequence number
        oneof update {
            string name = 2;
            Chain chain = 3;
            Host host = 4;
            IpAddrGroup ip_addr_group = 5;
            Network network = 6;
            Port port = 7;
            PortGroup port_group = 8;
            Route route = 9;
            Router router = 10;
            Rule rule = 11;
            TunnelZone tunnel_zone = 12;
            Vtep vtep = 13;
            VtepBinding vtep_binding = 14;
        }
    }
    oneof response {
        string name = 1;
        Ack ack = 2;
        NAck nack = 3;
        Deletion deletion = 4;
        Update update = 5;
    }
}
