// This file requests that any client of the Midonet cluster may issue
// to gain access to objects stored in the internal Midonet storage
import "commons.proto";
import "topology.proto";

package org.midonet.cluster.models;

option java_package = "org.midonet.cluster.rpc";
option java_outer_classname = "Commands";

// ------------------ MIDONET STORAGE API -----------------------------

//
// PROTOCOL
//
// The Midonet Storage API protocol defines the exchange of message between
// a Midonet topology client and the Midonet topology service. The data
// exchaged used the protobuf format; requests from the client consist
// of "Request" messages, and the responses from the server consist of
// "Response" messages - any particular type of information is encapsulated
// inside these two wrapper message types.
//
// This protocol becomes active when a low level communication channel has
// been established (e.g. a plain socket connection or a websocket connection).
// The protocol has three main states:
//   - Ready: this is the initial state. It transitions to Active after a
//       successful handshake, or to Closed after a network disconnection
//   - Active: this is the main state where the subscribe/unsubscribe
//       commands are accepted. It transitions to Closed after receiving
//       a 'Bye' command or after a network disconnection
//   - Closed: the connection is closed and more requests are accepted
//
// Common principles:
// -----------------
// All request commands have a compulsory req_id field. This id must be
// generated by the client and its only purpose is to be able to associate a
// particular request with its corresponding Ack or Nack responses.
//
// Hanshake procedure:
// ------------------
// The client should send a HandShake command inside a "Request" message.
// The 'cnxn_id' field must be generated by the client and will be used
// to identify a set of subscriptions. A client can recover a severed
// connection by sending the same cnxn_id in the new HandShake command (unless
// the disconnection was due to an explicit 'Bye' command).
// After sending the HandShake command, the client may receive:
//   - A "Response" message containing an "Ack", if the handshake was
//       successful.
//   - A "Response" message containing a "NAck", if the handshake failed. The
//       most likely reason for failure is specifying a cnxn_id that is already
//       in use from another connection; in this case, the client may retry
//       specifying a different cnxn_id in the HandShake command.
//
// Getting data, subscribing and unsubscribing:
// -------------------------------------------
// Getting data about an entity, and optionally subscribing to receive
// further updates, is done by sending a "Request" message containing a
// "Get" command. Apart from the compulsory 'req_id', the "Get" command
// must contain the type of the entity (or entities) to retrieve and,
// optionally, the following fields:
//   - id: the id of the entity to retrieve (if not present, all the entities
//     of the given type will be retrieved).
//   - subscribe: a boolean indicating if further updates about entity
//     modifications are to be received (if not present or false, only the
//     current state will be send). Note that, if no id is specified, new
//     objects of the given type will also be reported upon creation.
// After sending the Get command, the client may receive:
//   - A "Response" message containing a "Nack", if the Get request was
//     unsuccessful (e.g. trying to get data about a non-existing id).
//   - A "Response" message containing an "Ack", if the Get request was
//     correctly received and processed. Note that "Ack" indicates that the
//     request was correct, but not necessarily that it was 'successful' (e.g.
//     a subscription to a specific entity may return an 'ack' for the
//     subscription, followed by an 'error' indicating that the specific
//     entity does not exist).
//     The non-subscription queries may return the 'ack' piggy-backed with
//     the data, indicating the request id in the response.
//   - One or more "Response" messages containing either "Update", "Deletion"
//     or "Snapshot" responses, corresponding to the requested items.
//   - An "Error" message indicating that something failed in the operation
//     (for example, trying to watch a single entity that does not exist, or
//     a loss of connection to the storage backend).
// Note that subscriptions are idempotent: multiple subscriptions to the same
// entities do not result in multiple copies of the updates. In this case,
// a "Redirect" message is sent, indicating the original request id for that
// repeated subscription.
//
// A subscription can be revoked with a "Request" message containing an
// "Unsubscribe" command. Apart from the compulsory "req_id" and "type"
// fields, the command may optionally contain the id of the entity to forget
// about. If no id is specified, then the global per-type subscription will
// be cancelled (if any).
// After sending the Unsubscribe command, the client may receive:
//   - A "Response" message containing an "Ack", if the unsubscribe was
//       successful.
//   - A "Response" message containing a "NAck", if the unsubscribe failed.
//
// Termination:
// -----------
// A client can gracefully terminate the connection by issuing a "Request"
// message containing a "Bye" request. This request cancels all existing
// subscriptions for that client and terminates the session.
// Note that a session terminated with a "Bye" request cannot be resumed
// in a new connection.
// After sending the Bye Ack message, the server should terminate
// the connection.
//


// Used by clients to communicate commands to the cluster serving the
// Midonet topology. The first message after opening the connection must
// be a HANDSHAKE, followed by any number of GET, SUB, or UNSUB
// requests. A BYE message should be sent to the cluster to signal that
// the client is no longer interested in keeping the connection alive
// and its subscritions can be ignored. If this message is not sent, the
// cluster will assume a partition and try to remember the subscriptions
// from this client.
message Request {
    message Handshake {
        required UUID req_id = 1;         // Request id
        required UUID cnxn_id = 2;        // Connection identifier
        optional int64 seqno = 3;         // Last seen session sequence number
                                          // (for session recovery)
        optional string last_tx_id = 4;   // Last heard from the cluster,
                                          // if set, the cluster will
                                          // try to resend missed
                                          // updates
    }
    message Get { // Ask the cluster to provide the given entities
        required UUID req_id = 1;               // Request id
        required Type type = 2;                 // Entities of this type..
        optional UUID id = 3;                   // .. and id (which MUST
        optional bool subscribe = 4;            // .. and subscribe
    }
    message Unsubscribe { // Tell cluster to NOT send updates about it
        required UUID req_id = 1;        // Request id
        required Type type = 2;          // Type of the entity
        optional UUID id = 3;            // Id of the entity, if not
                                         // set, all the objects of type;
    }
    message Bye {   // Tell the cluster we're dropping the cnxn
        required UUID req_id = 1;
    }
    oneof request {
        Handshake handshake = 1;      // Connect to the cluster
        Get get = 2;                  // Get/Subscribe to some entities
        Unsubscribe unsubscribe = 3;  // Unsubscribe from some entities
        Bye bye = 4;                  // Disconnect from the cluster
    }
}

// Sent from the cluster to clients in response to Request messages:
// - Handshake: will be replied with an ACK/REJECT. If ACK, it will
//              include an identifier of the connection.
// - Data: will be replied with the latest known copy of the requested
//         entities for the cluster node that the client is connected to.
//         If the request was a subscription, it'll be followed by a new
//         copy of the data every time that the cluster becomes aware of
//         a change in the entity (including deletions).
// - Bye: not replied, the client can consider it a fire-and-forget

// Response types
enum ResponseType {
    ACK = 1;      // Request has been accepted
    REDIRECT = 2; // Redirect to a previous equivalent request
    NACK = 3;     // Request has been denied
    ERROR = 4;    // Error condition
    DELETION = 5; // Object deleted
    UPDATE = 6;   // Object updated
    SNAPSHOT = 7; // Object id list
}

message Response {
    message Redirect {
        optional UUID original_req_id = 1;
    }
    message Info {
        optional string msg = 1; // Informational message (for error conditions)
    }
    message Update {          // the latest known state of an entity
        oneof update {
            Chain chain = 1;
            Dhcp dhcp = 2;
            Host host = 3;
            IpAddrGroup ip_addr_group = 4;
            Network network = 5;
            Port port = 6;
            PortGroup port_group = 7;
            Route route = 8;
            Router router = 9;
            LoadBalancer load_balancer = 10;
            VIP vip = 11;
            Rule rule = 12;
            TunnelZone tunnel_zone = 13;
            Vtep vtep = 14;
            VtepBinding vtep_binding = 15;
        }
    }
    message Snapshot {
        repeated UUID obj_ids = 1;
    }

    required ResponseType type = 1;
    optional int64 seqno = 2;   // Session sequence number
    optional UUID req_id = 3;   // Request-specific indicator (used to
                                // piggy-back acks on non-subscription requests)
    optional Type obj_type = 4; // Referred object type (for deletion/update)
    optional UUID obj_id = 5;   // Referred object id (for deletion/update)
    oneof payload {
        Update update = 6;
        Snapshot snapshot = 7;
        Redirect redirect = 8;
        Info info = 9;
    }
}
