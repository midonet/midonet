#!/usr/bin/env python
# vim: tabstop=4 shiftwidth=4 softtabstop=4
#
# Copyright 2015 Midokura SARL
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import BaseHTTPServer
import urllib2
import SimpleHTTPServer
import SocketServer
import cmd
import re
import subprocess
import textwrap
from BaseHTTPServer import BaseHTTPRequestHandler
from pyhocon import ConfigFactory
from pyhocon import ConfigTree

# Misc utils

def indent_to(n):
    """A string of spaces indenting to level n"""
    t = ""
    while (n > 0):
        t += "  "
        n -= 1
    return t

def hoconToStr(hocon, level = 0, seed = ""):
    """Given a HOCON ConfigTree, return it as a string.  If `level` is
       given it will indent the output to the given level.

       TODO: this doesn't support lists or any minimally complex types,
       but not needede for now."""
    indent = indent_to(level)
    if (len(hocon) == 0):
        return seed + indent + "{}"

    for (k, v) in hocon.items():
        if (isinstance(v, ConfigTree)):
            seed += indent + k + " {\n" + hoconToStr(v, level + 1) + "\n"
            seed += indent + "}\n"
        else:
            seed += indent + k + " : " + str(v) + "\n"
    return seed

def out(text, outFile = None):
    """Output text to the given file, or stdout if none is given."""
    if outFile is None:
        print(text)
    else:
        with open(outFile, "w+") as fd:
            fd.write(textwrap.dedent("""\
                # This file has been automatically generated by
                # midonet-cluster-bootstrap.\n\n"""))
            fd.write(text)
            fd.close()

def extract_ips():
    result = {}
    currIfc = None
    # out = subprocess.check_output(("ip", "addr")).split("\n")
    out = subprocess.check_output("ifconfig").split("\n")
    for line in out:
        # if re.match("^\d+: [0-9a-zA-Z]+: ", line):
            # currIfc = line.split(": ")[1]
        if re.match("^[0-9a-zA-Z]+: ", line):
            currIfc = line.split(": ")[0]
            result[currIfc] = None
        elif re.match("\s+inet ", line):
            result[currIfc] = line.strip().split(" ")[1].split("/")[0]
    return {v for k, v in result.iteritems() if v != None}

def start_cluster():
    """Try to start the midonet-cluster service."""
    try:
        ret = subprocess.call(["sudo", "service", "midonet-cluster", "start"])
        if ret != 0:
            print "Error starting service"
    except OSError, e:
        print "Failed to start service", e

# The MultiNode HTTP server that the node leading the cluster bootstrap will
# expose to other nodes, obviously in a multi node setup.

class MultiNodeAgora(BaseHTTPRequestHandler):

    # TODO: there must be a more elegant way for the args
    def __init__(self, arg1, arg2, arg3):
        BaseHTTPRequestHandler.__init__(self, arg1, arg2, arg3)
        self.lead = None

    def do_GET(self):
        self.__handle()

    def do_POST(self):
        self.__handle()

    def __handle(self):
        if self.path == "/join":
            self.__do_join()
        elif self.path == "/peek":
            self.__do_peek()
        else:
            self.send_error(404,'Not Found (please use POST): %s' % self.path)

    def __do_join(self):
        cl = int(self.headers['Content-Length'])
        remote_ip = self.rfile.read(cl)
        print textwrap.dedent("""\
            \o/ we have a new member claiming mgmt IP %s""" % remote_ip)

        r = raw_input("Shall we accept this node into the cluster? [y/n] ")
        if r == "y":
            self.lead.add_member(remote_ip)
            curr_members = self.lead.members
            self.send_response(200)
            self.end_headers()
            sMembers = ", ".join(curr_members)
            self.wfile.write(unicode(sMembers, "utf-8"))
            print "Member accepted: " + sMembers + "\n"
        else:
            self.send_error(403,'The operator rejects node at %s' % remote_ip)

    def __do_peek(self):
        print "%s is peeking the cluster" % self.client_address[0]
        self.send_response(200)
        self.end_headers()
        self.wfile.write(unicode(hoconToStr(self.lead.conf, 2),"utf-8"))

    def log_message(self, format, *args):
        return # silence these

# The MultiNode HTTP server that the node leading the cluster bootstrap will
# expose to other nodes, obviously in a multi node setup.
class NodeStarter(BaseHTTPRequestHandler):

    # TODO: there must be a more elegant way for the args
    def __init__(self, arg1, arg2, arg3):
        BaseHTTPRequestHandler.__init__(self, arg1, arg2, arg3)
        self.node = None

    def do_POST(self):
        if self.path == "/go":
            self.activate_node()

    def activate_node(self):
        print "The lead node asks me to start.."
        print "- Persist config"
        cl = int(self.headers['Content-Length'])
        self.node.conf = ConfigFactory.parse_string(self.rfile.read(cl))
        self.node.do_apply()
        print "- Start MidoNet Cluster service on this node"
        start_cluster()
        # TODO: conditional response to whether we started the service?
        #       not sure given that it'll take some time and we need to
        #       reply fast-ish
        self.send_response(204) # OK no content
        self.end_headers()

# Installer workflows

class Workflow(cmd.Cmd):

    DEFAULT_PORT = "2181"
    DEFAULT_MGMT_IP = "127.0.0.1"
    DEFAULT_OUTPUT = "/tmp/midonet-cluster.conf"
    # DEFAULT_OUTPUT = "/etc/midonet-cluster/midonet-cluster.conf"

    def __init__(self):
        cmd.Cmd.__init__(self)
        self.mgmt_ip = Workflow.DEFAULT_MGMT_IP
        self.members = set([self.mgmt_ip])
        self.conf = ConfigFactory.parse_string("")
        self.conf["zookeeper"] = ConfigTree()
        self.conf["zookeeper"]["root_key"] = '"/midonet"'
        self.update_zk_hosts()

    def emptyline(self):
        return

    def update_zk_hosts(self):
        self.conf["zookeeper"]["zookeeper_hosts"] = '"' + ", ".join(self.members) + '"'

    def do_mgmt_ip(self, s):
        print "This Cluster node's management address will be: " + s
        if s in extract_ips():
            self.mgmt_ip = s
            self.conf["zookeeper"]["zookeeper_hosts"] = s + ":" + self.mgmt_ip
        else:
            print "Error: IP `%s` isn't configured on any interface of this host" % s

    def help_mgmt_ip(self):
        print textwrap.dedent("""\
                Use this option to override the default management IP.
                This is the IP that the cluster will use for internal
                management communication.""")

    def do_show(self, s):
        print "This is the current configuration:\n\n" + hoconToStr(self.conf, 2)

    def do_apply(self, filename = DEFAULT_OUTPUT):
        print "Writing configuration to:", filename
        out(hoconToStr(self.conf), filename)
        start_cluster()

    def do_exit(self, line):
        return True

class SingleNode(Workflow):

    prompt = "bootstrap.single-node> "

    def __init__(self):
        Workflow.__init__(self)
        self.intro = textwrap.dedent("""\
            Single node bootstrap workflow.  Use `help` for options.

            NOT FOR PRODUCTION""")


class MultiNode(Workflow):
    prompt = "bootstrap.multi-node> "

    def __init__(self):
        Workflow.__init__(self)
        self.mgmt_ip = None
        self.am_i_lead = False
        self.intro = "Multi node bootstrap workflow.  Use `help`for options."

    def do_lead_bootstrap(self, ip):
        if self.mgmt_ip == None:
            print "ERROR: management IP is not set, use `mgmt_ip $IP` to set it."
            return
        print "Acting as bootstrap lead"
        self.register_members()
        self.do_form_cluster()

    def help_lead_bootstrap(self, ip):
        print textwrap.dedent("""Use this option to have the current
            node act as the leading one in the bootstrap process, using the
            current management IP.  A lead node will be reponsible to
            sync with other nodes as they come up, and determine when there
            are sufficient members to form a Cluster.""")

    def do_join(self, lead_ip):
        if self.am_i_lead:
            print textwrap.dedent("""\
                I can't join if I'm being the lead bootstrap node! You
                probably meant to run this command on other cluster
                nodes""")
        else:
            print "Joining cluster with IP %s, following lead node: %s" % (self.mgmt_ip, lead_ip)
            res = urllib2.urlopen("http://" + lead_ip + ":8080/join", self.mgmt_ip)
            self.await_lead_confirmation()

    def help_join(self):
        print textwrap.dedent("""Use this option if there is already a
                different node driving the bootstrap process.  This node
                will connect to the given management IP, and exchange
                configuration in order to participate in the
                cluster.""")

    def add_member(self, remote_ip):
        if self.am_i_lead:
            self.members.add(remote_ip)
            self.update_zk_hosts()
        else:
            print "Only the bootstrap lead may accept new members"

    def can_form_cluster(self):
        return len(self.members) >= 3


    def do_form_cluster(self):
        if not self.can_form_cluster():
            print "We can't form a cluster yet, not enough nodes"
            return
        print "Forming cluster.."
        print "- Persist config locally.."
        self.do_apply()
        print "- Activating nodes.."
        start_cluster()
        for m in self.members:
            if m != self.mgmt_ip:
                print "Activating member ", m
                payload = unicode(hoconToStr(self.conf, 2),"utf-8")
                res = urllib2.urlopen("http://" + m + ":8081/go", payload)
                if res.getcode() == 204:
                    print "Node " + m + " started correctly"
                else:
                    print "ERROR: node " + m + " failed to start correctly"

    def help_form_cluster(self):
        print textwrap.dedent("""\
                Use this option to persist the configuration and start
                the MidoNet cluster using all accepted nodes. """)

    def register_members(self):
        self.am_i_lead = True
        print textwrap.dedent("""\
            Go ahead with the multi-node bootstrap on the rest of
            cluster nodes.  This involves the following commands:

                bootstrap> multi-node
                bootstrap.multi-node> mgmt_ip <SOME_IP>
                bootstrap.multi-node> join %s
            """ % (self.mgmt_ip))

        print "Waiting for joining nodes to join.."

        handler = MultiNodeAgora
        handler.lead = self
        server = SocketServer.TCPServer((self.mgmt_ip, 8080), handler)
        pending = True
        while pending:
            server.handle_request()
            if self.can_form_cluster():
                print "The MidoNet Cluster is READY, members:", ", ".join(self.members)
                pending = raw_input("Form cluster? [y/n] ") == "n"

    def await_lead_confirmation(self):
        print "Joined cluster.  Awaiting signal from lead to start cluster"
        handler = NodeStarter
        handler.node = self
        server = SocketServer.TCPServer((self.mgmt_ip, 8081), handler)
        pending = True
        server.handle_request()
        print "All set. Bye!"


class Bootstrap(cmd.Cmd):
    """This class implements the command interpreter, simply exposing
    the two available bootstrap options (single, or multi node)"""

    intro = "MidoNet Cluster Bootstrap workflow"
    prompt = "bootstrap> "

    def emptyline(self):
        return

    def do_single_node(self, line):
        SingleNode().cmdloop()

    def help_single_node(self):
        print textwrap.dedent("""\
                 This workflow will configure a Cluster using a single
                 node.  You will be able to chose a management IP for
                 control-plane communication.

                 This is NOT recommended for production.""")

    def do_multi_node(self, line):
        MultiNode().cmdloop()

    def help_multi_node(self):
        print textwrap.dedent("""\
                 This workflow will configure a Cluster using multiple
                 nodes.  You will be prompted for the control plane
                 IPs to be used and guided while other nodes are started.

                 This is the recommended option for production.""")

    def do_exit(self, line):
        return True

    def help_exit(self):
        print "Exits the application"

if __name__ == '__main__':
    Bootstrap().cmdloop()
