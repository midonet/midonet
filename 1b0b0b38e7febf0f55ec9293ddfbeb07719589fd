{
  "comments": [
    {
      "key": {
        "uuid": "1ae5cdf2_87ba8ebe",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 7
      },
      "lineNbr": 291,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2015-09-21T10:23:20Z",
      "side": 1,
      "message": "this means all arp requests will have -1 as cookie?",
      "revId": "1b0b0b38e7febf0f55ec9293ddfbeb07719589fd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1ae5cdf2_47d7a6ed",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 7
      },
      "lineNbr": 291,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-09-21T10:34:27Z",
      "side": 1,
      "message": "yes.\n\nso, at first i was thinking i would give all generated packets to the input thread (UpcallProcessor it will be called), and it would then give them to the Simulation threads. but this is wasteful, and it\u0027s best to simulate the generated packets right after the main simulation when everything is nice and warm in the cache. \n\nhowever, the cookie will no longer be generated, it will come from the disruptor\u0027s sequence number.\n\nso if this is too shocking, i can forget about this and just keep generating an unique cookie, or i can pass a cookie to the get method and it will become associated with the arp loop; in this case, all arps generated from the arp loop will be identified by the cookie of the first simulation that needed it.",
      "parentUuid": "1ae5cdf2_87ba8ebe",
      "revId": "1b0b0b38e7febf0f55ec9293ddfbeb07719589fd",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}