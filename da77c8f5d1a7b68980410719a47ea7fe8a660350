{
  "comments": [
    {
      "key": {
        "uuid": "1a106d94_263a4be7",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservableNodeCache.scala",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2015-04-25T12:43:56Z",
      "side": 1,
      "message": "I don\u0027t think this is a good idea, you\u0027re forcing synchronisation on all users of this observable, not only your subscriber.\n\nIncidentally, I think we should use a private lock for this purpose, not `this`. But I think we should go for a different solution anyway.",
      "revId": "da77c8f5d1a7b68980410719a47ea7fe8a660350",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_2b396f41",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservableNodeCache.scala",
        "patchSetId": 2
      },
      "lineNbr": 100,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-27T08:38:28Z",
      "side": 1,
      "message": "Overhead is negligible. Can be easily optimized.",
      "parentUuid": "1a106d94_263a4be7",
      "revId": "da77c8f5d1a7b68980410719a47ea7fe8a660350",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_2611ab5d",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservableNodeCache.scala",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2015-04-25T12:43:56Z",
      "side": 1,
      "message": "I think this is loading the ONC with responsibilities that are not its own. The ONC models a simple update stream. It\u0027s up to subscribers to decide when to process updates (block until an expected value is received, etc.), deal with their own concurrency model, etc. without impacting other subscribers of the same observable.\n\nI think you can achieve the same goal in a much cleaner way using Observable operators. If I understand the code in MidoConf correctly, what you want is to ignore all updates until the emitted value has is \u003e\u003d version. You can do so like this (assuming o is an ObservableNodeCache[ChildData]))\n\no.filter(_.getStat.getVersion \u003e version)\n\nif you just care about the first element (I seem to remember this was the case) and want to block until it\u0027s emitted, then do:\n\no.filter(_.getStat.getVersion \u003e version).toBlocking.first\n\nif you want to get all the elements, but block until the next one is emitted, use .next instead of .first\n\nYou can also turn .first() into a future using .toFuture\n\nhttps://github.com/ReactiveX/RxJava/wiki/Blocking-Observable-Operators",
      "range": {
        "startLine": 122,
        "startChar": 8,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "da77c8f5d1a7b68980410719a47ea7fe8a660350",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_853cd4c9",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservableNodeCache.scala",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2015-04-26T11:24:11Z",
      "side": 1,
      "message": "Please review the new version.",
      "parentUuid": "1a106d94_2611ab5d",
      "range": {
        "startLine": 122,
        "startChar": 8,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "da77c8f5d1a7b68980410719a47ea7fe8a660350",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_cb47fbba",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservableNodeCache.scala",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-27T08:38:28Z",
      "side": 1,
      "message": "Galo, that approach does not work in the presence of multiple writers (you don\u0027t want \u003e version, you want \u003d\u003d version). The general pattern is:\n\nval version \u003d fetchVersion(set(...))\nonc.waitForVersion(version)\n\nWhich is more or less like a ZK sync. \n\nThis primitive can be synchronous or asynchronous, but I do think it makes sense to have it as a primitive here instead of ad-hoc code.",
      "parentUuid": "1a106d94_853cd4c9",
      "range": {
        "startLine": 122,
        "startChar": 8,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "da77c8f5d1a7b68980410719a47ea7fe8a660350",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_8edfd168",
        "filename": "cluster/src/main/scala/org/midonet/cluster/util/ObservableNodeCache.scala",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2015-04-27T09:56:58Z",
      "side": 1,
      "message": "After a f2f chat:\n\n- The approach works in this case (and the implementation provided in th new patch) because you use a set with version, so we\u0027re guaranteed that the filter condition evaluates properly.\n\n- The solution won\u0027t work so cleanly in a case where you don\u0027t use the set with version. There, you\u0027d rely on zxid, which you only know after doing the set, and you need to make sure that the observable is subscribed to before doing the update so the client side code might be a bit uglier.\n\n- D and myself disagree on whether the non-set-with-version use case needs to be considered now. IMO, given that the current use case works with the solution on (3), we should keep it as it uses standard Observable operators. D thinks it\u0027s worth considering the non-set-with-version use case.\n\nYou decide :P",
      "parentUuid": "1a106d94_cb47fbba",
      "range": {
        "startLine": 122,
        "startChar": 8,
        "endLine": 122,
        "endChar": 22
      },
      "revId": "da77c8f5d1a7b68980410719a47ea7fe8a660350",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}