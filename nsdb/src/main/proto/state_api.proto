//
// Copyright 2016 Midokura SARL
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import "commons.proto";

package org.midonet.cluster.models;

option java_package = "org.midonet.cluster.rpc";
option java_outer_classname = "State";

// ------------------------ MIDONET STATE TABLES API ------------------------

//
// Messages
// ========
// The MidoNet State API protocol defines the messages between a MidoNet state
// tables client and the MidoNet state service. These are encoded as binary
// Prococol Buffer messages and are of two types: (i) requests and
// (ii) responses.
//
// Transactions
// ============
// A pair of request-response messages is called a transaction. To match a
// request with a response, all requests must include a request identifier
// 64-bit integer that uniquely identifies the request for the client. The
// request_id is generated by the client, and the server will include the same
// identifier in a response that answers a request and completes the
// transaction.
//
// A transaction may indicate to requester that it needs to store the state
// of the exchange until receiving a response with the same request_id.
// However, in the interest of conserving resources, responses may be optional
// for certain types of transactions (depending on the server and client
// implementations, and may be considered complete as soon as the request is
// sent).
//
// Subscriptions
// =============
// A subscription is a long-term dialog between the state client and server
// and contains a sequence of transactions. During the subscription, the server
// initiates a new transaction for every notification it sends to the client
// with updated state table data.
//
// State Exchange Transactions
// ===========================
//
// 1. Subscribe Transaction
// ------------------------
//
// This is initiated by a SUBSCRIBE request sent by a client, which contains
// the following information of the state table being subscribed: the object
// class, object identifier, table name, optional list of arguments (e.g. the
// VLAN for a MAC-port bridge state table), and the version of the last
// snapshot available to the client).
//
// The server responds with an ACKNOWLEDGE message that contains a unique 64-bit
// number identifying the subscription. All subsequent requests for the same
// subscription must use the same subscription identifier.
//
// 2. Notify Transaction
// ---------------------
//
// This is a transaction implicitly initiated by a SUBSCRIBE request or by a
// REFRESH request sent by the client. It is responded by a NOTIFY response.
//
// There are several types NOTIFY messages:
//
// * A NOTIFY_COMPLETED indicates that the stream of updates has completed for
//   a subscribed state table. This is a terminal response for the subscription
//   and after this message the subscription_id is invalid. A code field
//   indicates the reason of completion (e.g. the table was deleted, NSDB down,
//   etc.)
//
// * A NOTIFY_UPDATE: SNAPSHOT contains the entries from the subscribed state
//   table with the table version number. The entries are expressed as key-value
//   with version pairs and must be interpreted by the client according to the
//   type of state table to which it is subscribed. The entire snapshot may be
//   divided into one more more NOTIFY_SNAPSHOT messages, in which case a type
//   field indicates the beginning and the end of the snapshot..
//
// * A NOTIFY_UPDATE: RELATIVE contains a list of differential updates since the
//   last successful notification. The updates are expressed as key-value with
//   version pairs and must be interpreted by the client according to the type
//   of state table to which it is subscribed. The values are optional and if
//   not present indicates the key has been deleted from the state table.
//
// 3. Unsubscribe Transaction
// --------------------------
//
// This is initiated by an UNSUBSCRIBE request sent by a client for a given
// subscription. It indicates to the server to stop sending notifications for
// this subscription and it is completed by an ACKNOWLEDGE response.
//
// 4. Ping Transaction
// -------------------
//
// This is initiated by a PING request sent by a client for a given
// subscription to test the connectivity to the server after a period of
// inactivity. The server replies with a PONG response.
//
// Versioning (optional)
// =====================
//
// The server may support versioning of updates. This versioning will reflect
// the sequence of changes in the NSDB and is subject to implementation (e.g.
// the version can be represented by the PZXID of the state table root, which
// indicates the last transaction that modified the children of the root node.)
// Therefore, the versions may not be consecutive.
//
// If the server supports versioning, SUBSCRIBE may request a differential
// update with respect to a specific past version. If the server can accommodate
// such a request, the client should expect the next notification a
// NOTIFY_UPDATE containing the list of updates since the requested version.
//
// When a server cannot accommodate a requested version (e.g. the server does
// not support versioning, the server missed the notification of that specific
// version, or the version has been evicted from the server's change cache)
// the client should expect the next notification a NOTIFY_UPDATE containing
// the complete list of key-value entries from the state table.
//
// A NOTIFY_UPDATE: SNAPSHOT will include the version of the table for which the
// snapshot was taken. A NOTIFY_UPDATE: RELATIVE will include both the current
// version of the table, and last version with respect to which the update
// applies. This will indicate to the client whether the complete sequence of
// updates was notified correctly.
//
// Errors
// ======
//
// When a request cannot be serviced by the server, the client should expect
// an ERROR response, with a code indicating the error type and a description
// text.

// Represents a table key or value. This allows the usage of 32-bit or 64-bit
// integers for simple keys/values (e.g. IPv4 addresses, MAC addresses, etc.)
// to prevent additional allocations. All other data types are serialized as a
// byte array.
message KeyValue {
    oneof data {
        uint32 data_32 = 1;
        uint64 data_64 = 2;
        bytes data_variable = 3;
    }
}

// Represents a protocol request message.
message ProxyRequest {

    // A SUBSCRIBE request: subscribes to the state table described by the
    // fields from the request. The request is answered by an ACKNOWDLEDGE
    // containing the subscription_id.
    // * last_version : If present and supported by the server, the client
    //                  expects a differential NOTIFY_UPADATE since the
    //                  specified version.
    message Subscribe {
        optional string object_class = 1;
        optional UUID object_id = 2;
        optional string key_class = 3;
        optional string value_class = 4;
        optional string table_name = 5;
        repeated string table_arguments = 6;
        optional uint64 last_version = 7;
    }

    // An UNSUBSCRIBE request: cancels an ongoing subscription. The request is
    // answered by an ACKNOWLEDGE.
    message Unsubscribe {
        optional uint64 subscription_id = 1;
    }

    // A PING request: verifies whether the server is reachable after a period
    // of inactivity.
    message Ping { }

    required uint64 request_id = 1;
    oneof data {
        Subscribe subscribe = 2;
        Unsubscribe unsubscribe = 3;
        Ping ping = 4;
    }

}

// Represents a protocol response message.
message ProxyResponse {

    // A NOTIFY response: sent by the sever to a client for a given
    // subscription, and for a previous SUBSCRIBE or REFRESH transaction
    // initiated by the client.
    message Notify {

        message Entry {
            optional KeyValue key = 1;
            optional KeyValue value = 2;
            optional int32 version = 3;
        }

        message Completed {
            enum Code {
                NSDB_ERROR = 1;
                UNHANDLED_ERROR = 2;
                SERVER_SHUTDOWN = 3;
            }

            optional Code code = 1;
            optional int32 nsdb_code = 2;
            optional string description = 3;
        }

        message Update {
            enum Type {
                SNAPSHOT = 1;
                RELATIVE = 2;
            }

            optional Type type = 1;
            optional uint64 current_version = 2;
            optional bool begin = 3;
            optional bool end = 4;
            repeated Entry entries = 5;
        }

        optional uint64 subscription_id = 1;
        oneof notification {
            Completed completed = 2;
            Update update = 4;
        }
    }

    // An ACKNOWLEDGE response
    message Acknowledge {
        optional uint64 subscription_id = 1;
        optional uint64 last_version = 2;
    }

    // A PONG response: verifies whether the server is reachable after a period
    // of inactivity.
    message Pong { }

    // An ERROR response: sent by a receiver when a request cannot be serviced.
    message Error {
        enum Code {
            UNKNOWN_MESSAGE = 1;
            UNKNOWN_PROTOCOL = 2;
            UNKNOWN_CLIENT = 3;
            NO_SUBSCRIPTION = 4;
            SERVER_SHUTDOWN = 5;
            INVALID_ARGUMENT = 6;
        }

        optional Code code = 1;
        optional string description = 2;
    }

    required uint64 request_id = 1;
    oneof data {
        Notify notify = 2;
        Acknowledge acknowledge = 3;
        Pong pong = 4;
        Error error = 5;
    }

}
