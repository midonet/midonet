//
// Copyright 2016 Midokura SARL
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import "commons.proto";

package org.midonet.cluster.models;

option java_package = "org.midonet.cluster.rpc";
option java_outer_classname = "State";

// ------------------------ MIDONET STATE TABLES API ------------------------

//
// Messages
// ========
// The MidoNet State API protocol defines the messages between a MidoNet state
// tables client and the MidoNet state service. These are encoded as binary
// Prococol Buffer messages and are of two types: (i) requests and
// (ii) responses.
//
// Transactions
// ============
// A pair of request-response messages is called a transaction. To match a
// request with a response, all requests must include a request identifier
// 64-bit integer that uniquely identifies the request for the client. The
// request_id is generated by the client, and the server will include the same
// identifier in a response that answers a request and completes the
// transaction.
//
// A transaction may indicate to requester that it needs to store the state
// of the exchange until receiving a response with the same request_id.
// However, in the interest of conserving resources, responses may be optional
// for certain types of transactions (depending on the server and client
// implementations, and may be considered complete as soon as the request is
// sent).
//
// Subscriptions
// =============
// A subscription is a long-term dialog between the state client and server
// and contains a sequence of transactions. During the subscription, the server
// initiates a new transaction for every notification it sends to the client
// with updated state table data.
//
// State Exchange Transactions
// ===========================
//
// 1. Subscribe Transaction
// ------------------------
//
// This is initiated by a SUBSCRIBE request sent by a client, which contains
// the following information of the state table being subscribed: the object
// class, object identifier, table name, optional list of arguments (e.g. the
// VLAN for a MAC-port bridge state table), and the version of the last
// snapshot available to the client).
//
// The server responds with an ACKNOWLEDGE message that contains a unique 64-bit
// number identifying the subscription. All subsequent requests for the same
// subscription must use the same subscription identifier.
//
// 2. Notify Transaction
// ---------------------
//
// This is a transaction implicitly initiated by a SUBSCRIBE request or by a
// REFRESH request sent by the client. It is responded by a NOTIFY response.
//
// There are four NOTIFY messages:
//
// * A NOTIFY_COMPLETED indicates that the stream of updates has completed for
//   a subscribed state table. This is a terminal response for the subscription
//   and after this message the subscription_id is invalid. A code field
//   indicates the reason of completion (e.g. the table was deleted, NSDB down,
//   etc.)
//
// * A NOTIFY_SNAPSHOT contains the entries from the subscribed state table
//   with the table version number. The entries are expressed as key-value
//   with version pairs and must be interpreted by the client according to the
//   type of state table to which it is subscribed. The entire snapshot may be
//   divided into one more more NOTIFY_SNAPSHOT messages, in which case a
//   sequence number indicates the order of messages and a last indicator
//   specifies when the entire snapshot was received.
//
// * A NOTIFY_UPDATE contains a list of updates since the last successful
//   notification, either a NOTIFY_SNAPSHOT or a NOTIFY_UPDATE. The updates
//   are expressed as (key, old-value, new-value) triplets and must be
//   interpreted by the client according to the type of state table to which it
//   it is subscribed. The values are optional and if not present indicates
//   the key is missing in the state table.
//
// 3. Unsubscribe Transaction
// --------------------------
//
// This is initiated by an UNSUBSCRIBE request sent by a client for a given
// subscription. It indicates to the server to stop sending notifications for
// this subscription and it is completed by an ACKNOWLEDGE response.
//
// 4. Refresh Transaction
// ----------------------
//
// This is initiated by a REFRESH request sent by a client for a given
// subscription and it indicates the server to abandon differential updates
// and send a NOTIFY_SNAPSHOT with the entire state table. After the snapshot
// the server will continue sending NOTIFY_UPDATE messages.
//
// 5. Ping Transaction
// -------------------
//
// This is initiated by a PING request sent by a client for a given
// subscription to test the connectivity to the server after a period of
// inactivity. It may also query the status of a particular subscription
// and it is completed by an ACKNOWLEDGE response.
//
// Versioning (optional)
// =====================
//
// The server may support versioning of updates. This versioning will reflect
// the sequence of changes in the NSDB and is subject to implementation (e.g.
// the version can be represented by the PZXID of the state table root, which
// indicates the last transaction that modified the children of the root node.)
// Therefore, the versions may not be consecutive.
//
// If the server supports versioning, both SUBSCRIBE and REFRESH may request
// a differential update with respect to a specific past version. If the
// server can accommodate such a request, the client should expect the next
// notification a NOTIFY_UPDATE containing the list of updates since the
// requested version.
//
// When a server cannot accommodate a requested version (e.g. the server does
// not support versioning, the server missed the notification of that specific
// version, or the version has been evicted from the server's change cache)
// the client should expect the next notification a NOTIFY_SNAPSHOT containing
// the complete list of key-value entries from the state table.
//
// A NOTIFY_SNAPSHOT will include the version of the table for which the
// snapshot was taken. A NOTIFY_UPDATE will include both the current version of
// the table, and last version with respect to which the update applies. This
// will indicate to the client whether the complete sequence of updates was
// notified correctly.
//
// Errors
// ======
//
// When a request cannot be serviced by the server, the client should expect
// an ERROR response, with a code indicating the error type and a description
// text.

// Represents a table key or value. This allows the usage of 32-bit or 64-bit
// integers for simple keys/values (e.g. IPv4 addresses, MAC addresses, etc.)
// to prevent additional allocations. All other data types are serialized as a
// byte array.
message KeyValue {
    oneof data {
        uint32 data_32 = 1;
        uint64 data_64 = 2;
        bytes data_variable = 3;
    }
}

// Represents a protocol request message.
message ProxyRequest {

    // A SUBSCRIBE request: subscribes to the state table described by the
    // fields from the request. The request is answered by an ACKNOWDLEDGE
    // containing the subscription_id.
    // * last_version : If present and supported by the server, the client
    //                  expects a differential NOTIFY_UPADATE since the
    //                  specified version.
    message Subscribe {
        optional string object_class = 1;
        optional UUID object_id = 2;
        optional string key_class = 3;
        optional string value_class = 4;
        optional string table_name = 5;
        optional string table_arguments = 6;
        optional uint64 last_version = 7;
    }

    // An UNSUBSCRIBE request: cancels an ongoing subscription. The request is
    // answered by an ACKNOWLEDGE.
    message Unsubscribe {
        optional uint64 subscription_id = 1;
    }

    // A REFRESH request: requests to the server to send a snapshot of the
    // state table for the given subscription and all updates following the
    // snapshot. The request is answered by an ACKNOWLEDGE (optional).
    message Refresh {
        optional uint64 subscription_id = 1;
        optional uint64 last_version = 2;
    }

    // A PING request: verifies whether the server is reachable after a period
    // of inactivity. An optional subscription identifier can be used to request
    // information on a particular subscription.
    message Ping {
        optional uint64 subscription_id = 1;
    }

    required uint64 request_id = 1;
    oneof data {
        Subscribe subscribe = 2;
        Unsubscribe unsubscribe = 3;
        Refresh refresh = 4;
        Ping ping = 5;
    }

}

// Represents a protocol response message.
message ProxyResponse {

    // A NOTIFY response: sent by the sever to a client for a given
    // subscription, and for a previous SUBSCRIBE or REFRESH transaction
    // initiated by the client.
    message Notify {

        message Entry {
            optional KeyValue key = 1;
            optional KeyValue value = 2;
            optional int32 version = 3;
        }

        message Completed {
            enum Code {
                NSDB_ERROR = 1;
                UNHANDLED_ERROR = 2;
            }

            optional Code code = 1;
            optional int32 nsdb_code = 2;
            optional string description = 3;
        }

        message Snapshot {
            optional uint64 current_version = 1;
            optional uint32 sequence_number = 2;
            optional bool last = 3;
            repeated Entry entries = 4;
        }

        message Update {
            optional uint64 current_version = 1;
            optional uint64 last_version = 2;
            repeated Entry entries = 3;
        }

        optional uint64 subscription_id = 1;
        oneof notification {
            Completed completed = 2;
            Snapshot snapshot = 3;
            Update update = 4;
        }
    }

    // An ACKNOWLEDGE response
    message Acknowledge {
        optional uint64 subscription_id = 1;
        optional uint64 last_version = 2;
    }

    // An ERROR response: sent by a receiver when a request cannot be serviced.
    message Error {
        enum Code {
            UNKNOWN_MESSAGE = 1;
            UNKNOWN_PROTOCOL = 2;
            NO_SUBSCRIPTION = 3;
            NO_TABLE = 4;
        }

        optional Code code = 1;
        optional string description = 2;
    }

    required uint64 request_id = 1;
    oneof data {
        Notify notify = 2;
        Acknowledge acknowledge = 3;
        Error error = 4;
    }

}
