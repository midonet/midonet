{
  "comments": [
    {
      "key": {
        "uuid": "1a106d94_fb2aa12a",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 215,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-19T09:40:15Z",
      "side": 1,
      "message": "eek, i see this is still a concurrentlinkedqueue :/",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_c35ffbe3",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 215,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2015-04-21T11:06:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1a106d94_fb2aa12a",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_5b21354c",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 257,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-19T09:40:15Z",
      "side": 1,
      "message": "arpLoopIsReady would need to be thread-safe, since this is called by the waker-upper. easiest way to do that is to have a volatile field holding the soonest time when we should arp. although we can discuss if it\u0027s really needed; i think there would have to be a spurious wake up of the simulation thread while its registered in the waker upper.",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_6d47164c",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 257,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2015-04-20T17:10:09Z",
      "side": 1,
      "message": "let\u0027s discuss F2F. ...but:\n\nmacsDiscovered:  this is thread-safe already.\n\n\narpLoopQ: this is not. however: maybe we can ignore it in shouldProcess() just as I did with expirations since we get guaranteed calls at flow invalidation check time? How frequent are those? I think Anything below 5 seconds could work. OTOH, adding a volatile with the time would be as easy as what I did in v1.8, with the scheduleOnce() calls, I could add it.\n\n\nUPDATE: done.",
      "parentUuid": "1a106d94_5b21354c",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_7bffd1aa",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 279,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-19T09:40:15Z",
      "side": 1,
      "message": "I would re-write this as:\n\nif ((cacheEntry ne null) \u0026\u0026 (cacheEntry.macAddr ne null) {\n  if (clock.time \u003e (cacheEntry.stale + stalenessJitter)) \n    arpForAddress(ip, port)\n  cacheEntry.macAddr\n} else {\n  arpForAddress(ip, port)\n  throw new ...\n}\n\nLess overall branching.",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_0d7022a4",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 279,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2015-04-20T17:10:09Z",
      "side": 1,
      "message": "Done, similar, more readable:\n\n      if (shouldArp(cacheEntry)) {\n            arpForAddress(ip, port)\n            if ((cacheEntry ne null) \u0026\u0026 (cacheEntry.macAddr ne null))\n                cacheEntry.macAddr\n            else\n                throw new NotYetException(waitForArpEntry(ip), s\"MAC for IP $ip unknown, suspending during ARP\")\n        } else {\n            cacheEntry.macAddr\n        }",
      "parentUuid": "1a106d94_7bffd1aa",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_60a6fd54",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 279,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-21T09:14:18Z",
      "side": 1,
      "message": "that means shouldArp is still duplicating the checks \"cacheEntry ne null) \u0026\u0026 (cacheEntry.macAddr ne null)\", which was my main concern.\n\nthe re-write seems wrong, because we\u0027re not ARPing when the entry is stale. \n\na more readable version would be:\n\nval mac \u003d arpIfNeeded(...)\nif (mac ne null) {\n  cacheEntry.macAddr\n} else {\n   throw new ...\n}",
      "parentUuid": "1a106d94_0d7022a4",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_1b285d33",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 281,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-19T09:40:15Z",
      "side": 1,
      "message": "I don\u0027t like it that we are always creating a new promise. We should get first to check if there\u0027s already a promise.\n\nI also don\u0027t like that. I think the ArpLoop should have a Promise, so we don\u0027t need the arpWaiters. Since we have to query the arpLoops in get(), I would re-write get as:\n\nif ((cacheEntry ne null) \u0026\u0026 (cacheEntry.macAddr ne null) {\n  if (clock.time \u003e (cacheEntry.stale + stalenessJitter)) \n    arpForAddress(ip, port)\n  cacheEntry.macAddr\n} else {\n  val loop \u003d arpForAddress(ip, port)\n  throw new NotYetException(loop.future)\n}",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_4d697abd",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 281,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2015-04-20T17:10:09Z",
      "side": 1,
      "message": "I had thought about single promise but didn\u0027t get around to it, will do.\n\n\nUPDATE: no, will do in a second patch, when we remove setAndGet, because removing arpWaiters breaks setAndGet, which waits for an entry for which we are not ARPing.",
      "parentUuid": "1a106d94_1b285d33",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_80ab391c",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 281,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-21T09:14:18Z",
      "side": 1,
      "message": "oki",
      "parentUuid": "1a106d94_4d697abd",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_bb30299f",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 294,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-19T09:40:15Z",
      "side": 1,
      "message": "What about first-emit jitter?",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_ed72e6ab",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 294,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2015-04-20T17:10:09Z",
      "side": 1,
      "message": "there is none, IMHO packet senders provide it for us, and I didn\u0027t want to delay them.",
      "parentUuid": "1a106d94_bb30299f",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_c0641124",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 294,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-21T09:14:18Z",
      "side": 1,
      "message": "oki, agreed",
      "parentUuid": "1a106d94_ed72e6ab",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_3b1c3913",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 378,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-04-19T09:40:15Z",
      "side": 1,
      "message": "check if they\u0027re the same?",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1a106d94_8d6372db",
        "filename": "midolman/src/main/scala/org/midonet/midolman/state/ArpRequestBroker.scala",
        "patchSetId": 4
      },
      "lineNbr": 378,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2015-04-20T17:10:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1a106d94_3b1c3913",
      "revId": "9bc243ed5ba3517f2ce7daaef329566430d7a72e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}