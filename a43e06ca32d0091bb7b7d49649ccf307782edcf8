{
  "comments": [
    {
      "key": {
        "uuid": "baada198_ae81684c",
        "filename": "nsdb/src/main/scala/org/midonet/cluster/services/vxgw/FloodingProxyHerald.scala",
        "patchSetId": 1
      },
      "lineNbr": 230,
      "author": {
        "id": 1002754
      },
      "writtenOn": "2015-10-13T15:38:08Z",
      "side": 1,
      "message": "could we takeFirst and map?",
      "revId": "a43e06ca32d0091bb7b7d49649ccf307782edcf8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baada198_0eadf488",
        "filename": "nsdb/src/main/scala/org/midonet/cluster/services/vxgw/FloodingProxyHerald.scala",
        "patchSetId": 1
      },
      "lineNbr": 230,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2015-10-13T17:26:47Z",
      "side": 1,
      "message": "I tried removing some redundant code only. I\u0027m not sure how map (or flat-map) would work because the final subscriber is determined by the tunnel-zone id which is emitted on next. The solution was to return a composite subscription, and asynchronously add the tz subscriber to it when the tz is emitted.\n\nNote: I checked that adding a subscriber to an unsubscribed subscription, makes the subscriber unsubscribed (L220). I didn\u0027t check whether subscribe() ignores an unsubscribed subscriber, although I guess that should be the case (L223).",
      "parentUuid": "baada198_ae81684c",
      "revId": "a43e06ca32d0091bb7b7d49649ccf307782edcf8",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}