{
  "comments": [
    {
      "key": {
        "uuid": "fafc7978_8ebf2cd0",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 51,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2014-12-03T08:35:49Z",
      "side": 1,
      "message": "Maybe using one of the Lock classes from the concurrent package would be fitting, but I don\u0027t mind keeping it as it is.",
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_8ea60cc0",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 51,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-03T08:58:14Z",
      "side": 1,
      "message": "Locks would not be sufficient you need synchronization too. What class in particular were you referring to?",
      "parentUuid": "fafc7978_8ebf2cd0",
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_6edbe81b",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 51,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2014-12-03T12:13:36Z",
      "side": 1,
      "message": "Mm for example a java.lang.util.Condition which would replace gcDone, gcStarted and gcSynchronization (I think).",
      "parentUuid": "fafc7978_8ea60cc0",
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_2e89e0ca",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 51,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-03T14:04:05Z",
      "side": 1,
      "message": "I\u0027m not sure it would reduce the number of needed variables. I guess we would need a condition to indicate when the gc thread can start, a condition to indicate when gc is over, and also a lock.\n\nDo you see a simpler way of doing this?",
      "parentUuid": "fafc7978_6edbe81b",
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_a4a04ff5",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 51,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2014-12-03T18:44:36Z",
      "side": 1,
      "message": "I\u0027d have to see more in detail, but we\u0027re talking of a difference of 5 lines at best :D I\u0027d merge as it is.",
      "parentUuid": "fafc7978_2e89e0ca",
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_8490ab96",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2014-12-03T18:44:36Z",
      "side": 1,
      "message": "should be a while to cover for spurious wakeups",
      "range": {
        "startLine": 53,
        "startChar": 16,
        "endLine": 53,
        "endChar": 18
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_24ad7f32",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-04T08:27:42Z",
      "side": 1,
      "message": "I did not know the thread could wake up although notify hasn\u0027t been called. Added the while loop.",
      "parentUuid": "fafc7978_8490ab96",
      "range": {
        "startLine": 53,
        "startChar": 16,
        "endLine": 53,
        "endChar": 18
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_0e921c57",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2014-12-03T09:22:31Z",
      "side": 1,
      "message": "I\u0027m not sure if this solves the deadlock. The problem is the following: if the waitForGc method enters the critical section below:\n\n        gcSynchronization.synchronized {\n            while (!gcDone) {\n                gcSynchronization.wait()\n            }\n        }\n\nbefore the selected block here, then the runnable cannot notify the completion of the GC because it cannot enter its own critical section to set gcDone\u003dtrue and call notify().\n\nCorrect me if I\u0027m wrong, but it looks like there is a strong possibility of the waitForGc holding a lock on gcSynchronization indefinitely. Is there something that I\u0027m missing?",
      "range": {
        "startLine": 57,
        "startChar": 12,
        "endLine": 60,
        "endChar": 13
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_2e7c4020",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-03T09:36:57Z",
      "side": 1,
      "message": "When a thread calls gcSynchronization.wait() it releases ownership of the monitor that it had previously acquired by entering the gcSynchronization.synchronized block:\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait()",
      "parentUuid": "fafc7978_0e921c57",
      "range": {
        "startLine": 57,
        "startChar": 12,
        "endLine": 60,
        "endChar": 13
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_6e764840",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1002751
      },
      "writtenOn": "2014-12-03T09:46:46Z",
      "side": 1,
      "message": "All right, my mistake then.",
      "parentUuid": "fafc7978_2e7c4020",
      "range": {
        "startLine": 57,
        "startChar": 12,
        "endLine": 60,
        "endChar": 13
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_aebaf0de",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 117,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2014-12-03T08:35:49Z",
      "side": 1,
      "message": "why is it needed to gc on teardown?",
      "range": {
        "startLine": 117,
        "startChar": 8,
        "endLine": 117,
        "endChar": 15
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_aea150ab",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 117,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-03T08:58:14Z",
      "side": 1,
      "message": "To make sure the gc thread is not blocked and unusable in future tests. This was causing the previous flakiness of gc-based tests.",
      "parentUuid": "fafc7978_aebaf0de",
      "range": {
        "startLine": 117,
        "startChar": 8,
        "endLine": 117,
        "endChar": 15
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_4496c395",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 117,
      "author": {
        "id": 1002731
      },
      "writtenOn": "2014-12-03T18:44:36Z",
      "side": 1,
      "message": "Ah ok, so you\u0027re just letting it run and then waiting for it to finish right?\n\nI guess maybe an easier alternative could be to interrupt it?",
      "parentUuid": "fafc7978_aea150ab",
      "range": {
        "startLine": 117,
        "startChar": 8,
        "endLine": 117,
        "endChar": 15
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fafc7978_84aa6b17",
        "filename": "cluster/src/test/scala/org/midonet/cluster/data/storage/ZookeeperObjectMapperTests.scala",
        "patchSetId": 8
      },
      "lineNbr": 117,
      "author": {
        "id": 1002820
      },
      "writtenOn": "2014-12-04T08:27:42Z",
      "side": 1,
      "message": "Since the gc thread now loops until gcStarted is true, it seems simpler to just call startGc() since we also have to set gcStarted to true.\n\nI added a comment to explain why this is done in teardown()",
      "parentUuid": "fafc7978_4496c395",
      "range": {
        "startLine": 117,
        "startChar": 8,
        "endLine": 117,
        "endChar": 15
      },
      "revId": "99d6ff120da9e3a844e0fc50e140415c82d33b07",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}