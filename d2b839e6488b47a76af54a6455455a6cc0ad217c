{
  "comments": [
    {
      "key": {
        "uuid": "baa041b7_8c5856fa",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-08-15T18:10:22Z",
      "side": 1,
      "message": "Use the UnixClock trait, so a mocked clock can be passed in.",
      "range": {
        "startLine": 78,
        "startChar": 12,
        "endLine": 78,
        "endChar": 37
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_c7087793",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2016-08-16T06:14:52Z",
      "side": 1,
      "message": "I\u0027m embarrassed I didn\u0027t think of that myself.",
      "parentUuid": "baa041b7_8c5856fa",
      "range": {
        "startLine": 78,
        "startChar": 12,
        "endLine": 78,
        "endChar": 37
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_4c6fee91",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-08-15T18:10:22Z",
      "side": 1,
      "message": "why do you ever need to check the header when writing? If a agent is restarted, it should start with an empty file.",
      "range": {
        "startLine": 191,
        "startChar": 9,
        "endLine": 191,
        "endChar": 18
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_a7fb337a",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2016-08-16T06:14:52Z",
      "side": 1,
      "message": "So you\u0027re saying it should always roll over on creation? That\u0027s not obviously wrong, but it\u0027s also not obvious to me that that\u0027s the right thing to do. I asked Ryu about it and he seemed skeptical, too. Let\u0027s check with the architects and see what they want.",
      "parentUuid": "baa041b7_4c6fee91",
      "range": {
        "startLine": 191,
        "startChar": 9,
        "endLine": 191,
        "endChar": 18
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_20d6eaf1",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-08-16T15:40:30Z",
      "side": 1,
      "message": "What is the advantage of reusing the same file?",
      "parentUuid": "baa041b7_a7fb337a",
      "range": {
        "startLine": 191,
        "startChar": 9,
        "endLine": 191,
        "endChar": 18
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_c654f6ff",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2016-08-17T03:58:00Z",
      "side": 1,
      "message": "Preservation of the specified rotation policy. If you specify rotation once per day, you get one log file per day. If you specify once per hour, you get one log file per hour. If you specify rotation every 100MB, you get a bunch of 100MB log files (approximately, subject to the constraint that writes be atomic).",
      "parentUuid": "baa041b7_20d6eaf1",
      "range": {
        "startLine": 191,
        "startChar": 9,
        "endLine": 191,
        "endChar": 18
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_e665ba1d",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-08-17T08:41:00Z",
      "side": 1,
      "message": "For the cost of a lot more complexity. You don\u0027t just check the header. You need to to scan the whole file, because you need to find the boundary of the last valid entry. The process may have crashed with a partial write. Then there\u0027s the issue of schema change. With a new file per process instance, it isn\u0027t a problem. But you\u0027ll end up mixing schemas if you reuse.\n\nI don\u0027t see a couple of extra files around reboots to be problematic. The agent should run for months at a time anyhow, so for the common case it will match the policy you describe.",
      "parentUuid": "baa041b7_c654f6ff",
      "range": {
        "startLine": 191,
        "startChar": 9,
        "endLine": 191,
        "endChar": 18
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_ef622d3d",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2016-08-31T07:20:36Z",
      "side": 1,
      "message": "Fixed in latest patch.",
      "parentUuid": "baa041b7_e665ba1d",
      "range": {
        "startLine": 191,
        "startChar": 9,
        "endLine": 191,
        "endChar": 18
      },
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_8c0f36df",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 212,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-08-15T18:12:34Z",
      "side": 1,
      "message": "What\u0027s to stop a roll happening in the middle of a record?\n\nI don\u0027t think you should make this inherit from OutputStream, as you have an implicit contract with the upper layer that you\u0027ll be writing a block at a time. Rather, just expose a simpler interface, that you can only write a block to.",
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_e705bb79",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 212,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2016-08-16T06:14:52Z",
      "side": 1,
      "message": "I see your point, but the only OutputStream method that doesn\u0027t really make sense here is write(Int). So I guess I could create a different interface that\u0027s the same as OutputStream minus that one method.\n\nBut keep in mind that this needs to share a common interface with the streams that we use for other logging implementations (e.g., I believe we have plans to implement logging over the network). It\u0027s not a big deal, bordering on trivial, to create a shim that wraps a socket\u0027s OutputStream in BlockOutputStream, or whatever we want to call it, but it seems like this just adds an unnecessary layer of complexity.\n\nThe alternative is to say that RollingOutputStream can roll over between writes, because that\u0027s what it does. There\u0027s nothing in the interface that implies the ability to group multiple writes into an atomic transaction that can\u0027t be interrupted by a rollover. If it had startTransaction() and endTransaction() methods and didn\u0027t honor them, that would be one thing, but I don\u0027t think this fails to deliver anything it promises.",
      "parentUuid": "baa041b7_8c0f36df",
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_e006c284",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 212,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-08-16T15:40:30Z",
      "side": 1,
      "message": "ok, well maybe there\u0027s no contract that states you cannot roll in the middle of a write, but that implies more complexity when reading the binary entries. If you roll in the middle of a write, how do you know were to start reading from (keeping in mind that the old rolled logs may no longer be retained).",
      "parentUuid": "baa041b7_e705bb79",
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_a659f237",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 212,
      "author": {
        "id": 1002821
      },
      "writtenOn": "2016-08-17T03:58:00Z",
      "side": 1,
      "message": "It doesn\u0027t roll in the middle of a write. It rolls between writes. Whatever data you pass to a single write() call will be written atomically, so if you need something to be written atomically, you should pass it into a single write() call.",
      "parentUuid": "baa041b7_e006c284",
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baa041b7_c66ab6ed",
        "filename": "midonet-util/src/main/scala/org/midonet/util/logging/RollingOutputStream.scala",
        "patchSetId": 1
      },
      "lineNbr": 212,
      "author": {
        "id": 1003555
      },
      "writtenOn": "2016-08-17T08:41:00Z",
      "side": 1,
      "message": "This is the implicit contract I was talking about. The underlying stream expects blocks of bytes to be written at a time. There\u0027s nothing in the interface provided to the caller that enforces this though.",
      "parentUuid": "baa041b7_a659f237",
      "revId": "d2b839e6488b47a76af54a6455455a6cc0ad217c",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}